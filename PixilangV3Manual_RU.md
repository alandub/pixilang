

# Что такое Pixilang #

Pixilang - кросс-платформенный язык программирования для небольших графических и звуковых приложений. Примеры применения: арт-эксперименты, демки (demoscene), синтезаторы, игры. Концепция языка разработана в 2006 году Александром Золотовым (NightRadio) и Михаилом Разуваевым (Goglus).

Pixilang-программы хранятся в текстовых файлах (UTF8) с расширением .txt или .pixi. Поэтому вы можете использовать любой текстовый редактор для создания таких программ. Pixilang не имеет встроенного редактора. После старта появляется файловый диалог, в котором нужно указать, где лежит запускаемая pixi-программа.

Ключевые особенности:
  * простые правила, низкий порог вхождения;
  * поддержка графических и звуковых форматов файлов;
  * программу можно писать без объявления функций, просто списком инструкций с условными переходами;
  * сразу после старта программе выделяется чистый экран (или окно), к которому можно обращаться как к массиву пикселей, или использовать готовые граф. примитивы.

# Запуск из командной строки #

При запуске из командной строки Pixilang принимает дополнительные опции в приведенном ниже формате.
```
pixilang [options] [source_file_name]
[options]
  -c    генерация байт-кода; будет создан файл source_file_name.pixicode.
        Примечание: файлы в формате *.pixicode привязаны к архитектуре и могут неправильно работать на других устройствах.
```

# Основы #

В основе Pixilang - контейнеры (или pixi-контейнеры, как их иногда называют) и переменные.

Что такое контейнер? Если в двух словах, то это двумерный массив, таблица из X колонок и Y строк. Каждая ячейка этой таблицы - число определенного формата. Формат задан один на весь контейнер. Например, ячейки могут хранить цвета пикселей, тогда контейнер превращается в картинку. Контейнер с таким же успехом может быть строкой текста, куском звука и т.д. Если вы знакомы с другими языками программирования, то считайте контейнер массивом, состоящим из (X\*Y) ячеек. Каждый контейнер после создания имеет свой порядковый номер.

Структура контейнера:
  * двумерный массив (таблица) элементов контейнера;
  * key color - цвет, который будет отображаться, как прозрачный;
  * ссылка на контейнер (должен быть типа INT8) с альфа-каналом - для изображений с плавными изменениями прозрачности;
  * дополнительные данные:
    * свойства (используйте функции get\_prop(), set\_prop(), remove\_props() или оператор . (точка) для доступа к ним);
    * анимация (используйте функции для анимации контейнеров).

Новый контейнер можно получить используя функцию new() или какую-то другую специальную функцию, возвращающую блок данных. Контейнер удаляется двумя способами:
  * пользователем при помощи функции remove();
  * автоматически после завершения программы.
В Pixilang отсутствует автоматический сборщик мусора, поэтому будьте внимательны - каждый новый контейнер отнимает память до тех пор, пока вы не удалите этот контейнер.

Переменная - имя ячейки памяти, в которой хранится одно знаковое целое 32-битное число (например, 25) или 32-битное число с плавающей запятой (например, 33.44). Локальные переменные (с символом $ перед именем) доступны только в рамках одной функции, в которой эти переменные определены. Глобальные переменные (без символа $) доступны в любом месте программы.

Числа можно описывать в различных форматах. Примеры:
  * 33 - обычное целое десятичное;
  * 33.55 - десятичное с плавающей запятой;
  * 0xA8BC - шестнадцатеричное;
  * 0b100101011 - двоичное;
  * #FF9080 - цвет, как в HTML; общий формат такой: #RRGGBB, где RR - яркость красного, GG - яркость зеленого; BB - яркость голубого.
В каком бы формате вы не описали число, внутри Pixilang оно все равно будет 32-битным целым или 32-битным с плавающей запятой.

Простейшие примеры применения контейнеров и переменных:
```
x = new( 4 ) //Создаем контейнер из 4х пикселей. Сохраняем номер контейнера в переменной x.
x[ 2 ] = WHITE //Присваиваем пикселю номер 2 белый цвет.
remove( x ) //Удаляем контейнер
```
```
c = new( 4, 4 ) //Создаем 2D контейнер 4 на 4 пикселя. Сохраняем номер контейнера в переменной c.
c[ 2, 2 ] = WHITE //Присваиваем пикселю с координатами 2,2 белый цвет.
remove( c ) //Удаляем контейнер
```
```
str = "Hello" //"Hello" - это строковый контейнер, состоящий из пяти 8-битных символов (кодировка UTF-8).
//Подобные контейнеры-строки создаются автоматически на этапе компиляции программы.
//Удалять их вручную так, как это сделано в предыдущем примере, не надо.
//Контейнеру со строкой "Hello" автоматически присвоится порядковый номер.
//Например, это будет номер 4.
//Тогда код str = "Hello" будет равноценен коду str = 4.
str[ 0 ] = 'h' //Меняем самую первую букву в строке. Было - 'H'. Станет - 'h'.
```
```
a = 4 //Глобальная переменная
fn function()
{
  $k = 2 //Локальная переменная
  function2 = {
    //Определяем еще одну функцию
    $x = 899.334 //Локальная переменная
    //В этом месте $k недоступна, т.к. находится в другой функции
  }
  //В этом месте $x недоступна
}
//В этом месте $k и $x недоступны
```

# Имена файлов и директорий #

Ниже приведены примеры, показывающие основные правила оформления имен файлов и директорий.
```
//Файл спрятан в нескольких директориях относительно текущего местоположения пикси-программы:
"folder1/folder2/folder3/prog.pixi"

//Файл лежит в текущей рабочей папке Pixilang
//  для iOS: documents; 
//  для WinCE: корень файловой системы (/);
//  для остальных систем: в той же самой папке, в которой лежит pixilang или pixilang.exe; 
"1:/prog.pixi"

//Файл лежит в директории пользователя (например, в Linux это будет /home/alex):
"2:/prog.pixi"

//Файл лежит во временной директории:
"3:/prog.pixi"
```

# Встроенные операторы #

Рассмотрим операторы на конкретных примерах.

```
//Условные операторы if, else
if a == b 
  { /*Код в этом месте выполняется, если a равно b*/ }
else
  { /*Код в этом месте выполняется в противном случае (a не равно b)*/ }
if x == 4 && y == 2 
  { /*Код в этом месте выполняется, если x равно 4 и y равно 2*/ }

//Оператор цикла: while
a = 0
while( a < 3 )
{
  //Код в этом месте выполняется, если a меньше 3
  a + 3
}

//Операторы цикла: while, break
a = 0
while( a < 100 )
{
  //Код в этом месте выполняется, если a меньше 100
  if a == 10 { break } //Если a = 10, то разрываем цикл оператором break
  //Для остановки нескольких вложенных циклов сразу можно использовать оператор breakX,
  //где X - глубина. Например break2 остановит два цикла.
  //А при помощи оператора breakall можно остановить все циклы, 
  //которые активны в данный момент для текущего потока выполнения.
  a + 1
}

//Операторы цикла: while, continue
a = 0
b = 0
while( a < 100 )
{
  //Код в этом месте выполняется, если a меньше 100
  if a == 10 { a + 1 continue } //Если a = 10, то переходим к следующей итерации цикла
                                //             (игнорируем следующие две строчки кода)
  a + 1
  b + 1
}

//Операторы перехода: go, goto
m1:
a + 1
goto m1 //Переход на метку m1

//Операторы остановки: halt, stop
halt //В этом месте программа останавливается

//Оператор подключения: include
include "prog2.txt" //В этом месте подключаем код из файла prog2.txt

//Оператор определения функции: fn
fn fff( $x, $y ) //Определяем функцию fff с параметрами $x и $y
{
  //Код функции fff
  ret //Простой выход из функции
  ret( 4 ) //Выход из функции с возвращением значения 4
}
```

Ниже приведена таблица математических операторов. Приоритет 0 - наивысший, такие операции будут выполняться в первую очередь.
| Приоритет | Оператор | Описание | Результат | Пример |
|:----------|:---------|:---------|:----------|:-------|
| 0         | %        | Деление по модулю | Целое число | a = b % 4 |
| 0         | /        | Деление  | Число с плавающей запятой | a = b / 4 |
| 0         | div      | Целочисленное деление | Целое число | a = b div 4 |
| 0         | `*`      | Умножение | Зависит от операндов | a = b `*` 4 |
| 1         | +        | Сложение | Зависит от операндов | a = b + 4 |
| 1         | -        | Вычитание | Зависит от операндов | a = b - 4 |
| 2         | >>       | Битовый сдвиг вправо | Целое число | a = b >> 4 |
| 2         | <<       | Битовый сдвиг влево | Целое число | a = b << 4 |
| 3         | ==       | Равно    | Целое число 1 или 0 | if a == b {} |
| 3         | !=       | Не равно | Целое число 1 или 0 | if a != b {} |
| 3         | <        | Меньше   | Целое число 1 или 0 | if a < b {} |
| 3         | >        | Больше   | Целое число 1 или 0 | if a > b {} |
| 3         | <=       | Меньше или равно | Целое число 1 или 0 | if a <= b {} |
| 3         | >=       | Больше или равно | Целое число 1 или 0 | if a >= b {} |
| 4         | |        | Побитовая операция ИЛИ (OR) | Целое число | a = b | 4 |
| 4         | ^        | Побитовая операция исключающего ИЛИ (XOR) | Целое число | a = b ^ 4 |
| 4         | &        | Побитовая операция И (AND) | Целое число | a = b & 4 |
| 5         |  `|``|`  | Логическая операция ИЛИ (OR) | Целое число 1 или 0 | if a `|``|` b {} |
| 5         | &&       | Логическая операция И (AND) | Целое число 1 или 0 | if a && b {} |

# Встроенные константы #

## Типы контейнеров ##

Контейнер может содержать элементы одного из нижеперечисленных типов.

64-битные типы в текущей версии не поддерживается, но поддержка может быть включена при самостоятельной сборке Pixilang из исходников. Для включения необходимо внести небольшие правки в файле pixilang.h в разделе Configuration.

  * INT - знаковое целое (размер зависит от версии Pixilang);
  * INT8 - знаковое целое (8 бит); диапазон значений: от -128 до 127;
  * INT16 - знаковое целое (16 бит); диапазон значений: от -32768 до 32767;
  * INT32 - знаковое целое (32 бита); диапазон значений: от -2147483648 до 2147483647;
  * INT64 - знаковое целое (64 бита);
  * FLOAT - плавающая запятая (размер зависит от версии Pixilang);
  * FLOAT32 - плавающая запятая (32 бита);
  * FLOAT64 - плавающая запятая (64 бита);
  * PIXEL - пиксель; после создания контейнера это значение превращается в INTx, где x - кол-во бит на пиксель.

## Флаги (опции) контейнера ##

  * CFLAG\_INTERP - включить программную интерполяцию.

Для OpenGL:
  * GL\_MIN\_LINEAR;
  * GL\_MAG\_LINEAR;
  * GL\_NICEST - использовать наилучшее отображение и 32-битный цвет, когда возможно;
  * GL\_NO\_XREPEAT;
  * GL\_NO\_YREPEAT;
  * GL\_NO\_ALPHA.

## Флаги (опции) для функции resize() ##

  * RESIZE\_INTERP1 - грубое масштабирование;
  * RESIZE\_INTERP2 - масштабирование с линейной интерполяцией;
  * RESIZE\_UNSIGNED\_INTERP2 - аналогично RESIZE\_INTERP2, но все числа контейнера рассматриваются как беззнаковые;
  * RESIZE\_COLOR\_INTERP1 - аналогично RESIZE\_INTERP1, но для цветов пикселей;
  * RESIZE\_COLOR\_INTERP2 - аналогично RESIZE\_INTERP2, но для цветов пикселей.

## Флаги (опции) для функции copy() ##

  * COPY\_NO\_AUTOROTATE - не переворачивать данные после копирования из GL\_SCREEN.

## Размеры ##

  * INT\_SIZE - максимальный размер (в байтах) знакового целого числа, с которым может работать Pixilang.
  * FLOAT\_SIZE - максимальный размер (в байтах) числа с плавающей запятой, с которым может работать Pixilang.
  * INT\_MAX - максимальное положительное целое;
  * COLORBITS - количество бит на пиксель.

## ZLib ##

Уровни компрессии:
  * Z\_NO\_COMPRESSION;
  * Z\_BEST\_SPEED;
  * Z\_BEST\_COMPRESSION;
  * Z\_DEFAULT\_COMPRESSION.

## Типы файлов ##

  * FORMAT\_RAW;
  * FORMAT\_JPEG;
  * FORMAT\_PNG;
  * FORMAT\_GIF;
  * FORMAT\_WAVE;
  * FORMAT\_AIFF (поддерживается только загрузка AIFF файлов);
  * FORMAT\_PIXICONTAINER - весь контейнер целиком (со свойствами и анимацией).

## Опции для load() и save() ##

  * LOAD\_FIRST\_FRAME - загрузить только первый кадр.

Сохранение GIF:
  * GIF\_GRAYSCALE;
  * GIF\_DITHER.

Сохранение JPEG:
  * `JPEG_H1V1 - YCbCr, no subsampling (H1V1, YCbCr 1x1x1, 3 blocks per MCU);`
  * `JPEG_H2V1 - YCbCr, H2V1 subsampling (YCbCr 2x1x1, 4 blocks per MCU);`
  * `JPEG_H2V2 - YCbCr, H2V2 subsampling (YCbCr 4x1x1, 6 blocks per MCU); default;`
  * `JPEG_TWOPASS - удвоенное количество проходов.`

## Цвета ##

  * ORANGE - ораньжевый;
  * BLACK - черный;
  * WHITE - белый;
  * YELLOW - желтый;
  * RED - красный;
  * GREEN - зеленый;
  * BLUE - синий.

## Выравнивание ##

Эти константы используются, например, при выводе текста. Их можно комбинировать при помощи побитовой операции ИЛИ (|).
Отсутствие TOP и BOTTOM обозначает вертикальное выравнивание по центру.
Отсутствие LEFT и RIGHT обозначает горизонтальное выравнивание по центру.

  * TOP - по верхнему краю;
  * BOTTOM - по нижнему краю;
  * LEFT - по левому краю;
  * RIGHT - по правому краю.

## Типы эффектов ##

Типы эффектов для функции effector():
  * EFF\_NOISE - шум;
  * EFF\_SPREAD\_LEFT - случайные сдвиги пикселей влево;
  * EFF\_SPREAD\_RIGHT - случайные сдвиги пикселей вправо;
  * EFF\_SPREAD\_UP - случайные сдвиги пикселей вверх;
  * EFF\_SPREAD\_DOWN - случайные сдвиги пикселей вниз;
  * EFF\_HBLUR - горизонтальное размывание;
  * EFF\_VBLUR - вертикальное размывание;
  * EFF\_COLOR - сплошная заливка одним цветом.

## OpenGL ##

Режимы для gl\_draw\_arrays() (аналог функции glDrawArrays()):
  * GL\_POINTS;
  * GL\_LINE\_STRIP;
  * GL\_LINE\_LOOP;
  * GL\_LINES;
  * GL\_TRIANGLE\_STRIP;
  * GL\_TRIANGLE\_FAN;
  * GL\_TRIANGLES.

Константы для gl\_blend\_func() (аналог функции glBlendFunc()):
  * GL\_ZERO;
  * GL\_ONE;
  * GL\_SRC\_COLOR;
  * GL\_ONE\_MINUS\_SRC\_COLOR;
  * GL\_DST\_COLOR;
  * GL\_ONE\_MINUS\_DST\_COLOR;
  * GL\_SRC\_ALPHA;
  * GL\_ONE\_MINUS\_SRC\_ALPHA;
  * GL\_DST\_ALPHA;
  * GL\_ONE\_MINUS\_DST\_ALPHA;
  * GL\_SRC\_ALPHA\_SATURATE.

Глобальные OpenGL контейнеры:
  * GL\_SCREEN; вы не можете обращаться к экрану GL\_SCREEN, как к массиву пикселей напрямую, но вы можете использовать для этих целей функцию copy( dest, GL\_SCREEN );
  * GL\_ZBUF.

## Звук ##

Флаги для функции set\_audio\_callback():
  * AUDIO\_FLAG\_INTERP2 - линейная интерполяция ( по двум точкам).

## MIDI ##

Флаги для функций midi\_get\_device(), midi\_open\_port():
  * MIDI\_PORT\_READ;
  * MIDI\_PORT\_WRITE.

## События ##

  * EVT - номер контейнера, в который помещается событие из функции get\_event().
Номера ячеек (полей) в контейнере EVT:
  * EVT\_TYPE - тип;
  * EVT\_FLAGS - флаги;
  * EVT\_TIME - время;
  * EVT\_X - координата X (0 - центр экрана);
  * EVT\_Y - координата Y (0 - центр экрана);
  * EVT\_KEY - ASCII код нажатой клавиши, или одна из констант KEY\_xxx;
  * EVT\_SCANCODE - сканкод (если имеется) или номер нажатия на экран (только для multitouch устройств; от нуля);
  * EVT\_PRESSURE - давление нажатия (норма = 1024);
  * EVT\_UNICODE - юникод (если имеется).
Типы событий (для поля EVT\_TYPE):
  * EVT\_MOUSEBUTTONDOWN - клик мышкой, первое нажатие на экран;
  * EVT\_MOUSEBUTTONUP;
  * EVT\_MOUSEMOVE;
  * EVT\_TOUCHBEGIN - второе, третье и т.д. нажатие на экран (только для multitouch устройств);
  * EVT\_TOUCHEND;
  * EVT\_TOUCHMOVE;
  * EVT\_BUTTONDOWN;
  * EVT\_BUTTONUP;
  * EVT\_SCREENRESIZE;
  * EVT\_QUIT - виртуальная машина будет закрыта; если при этом `EVT[ EVT_SCANCODE ] = 0`, то данное событие нельзя игнорировать, виртуальная машина может подождать пользовательский код максимум 0.5 секунды; а если `EVT[ EVT_SCANCODE ] = 1`, то событие можно игнорировать, например выдать диалоговое окно "Вы действительно хотите выйти?".
Флаги события (для поля EVT\_FLAGS):
  * EVT\_FLAG\_SHIFT;
  * EVT\_FLAG\_CTRL;
  * EVT\_FLAG\_ALT;
  * EVT\_FLAG\_MODE;
  * EVT\_FLAG\_MODS (маска модификаторов со всеми флагами типа Shift, Ctrl и т.д.);
  * EVT\_FLAG\_DOUBLECLICK.
Коды клавиш (для поля EVT\_KEY):
  * KEY\_MOUSE\_LEFT;
  * KEY\_MOUSE\_MIDDLE;
  * KEY\_MOUSE\_RIGHT;
  * KEY\_MOUSE\_SCROLLUP;
  * KEY\_MOUSE\_SCROLLDOWN;
  * KEY\_BACKSPACE;
  * KEY\_TAB;
  * KEY\_ENTER;
  * KEY\_ESCAPE;
  * KEY\_SPACE;
  * KEY\_F1;
  * KEY\_F2;
  * KEY\_F3;
  * KEY\_F4;
  * KEY\_F5;
  * KEY\_F6;
  * KEY\_F7;
  * KEY\_F8;
  * KEY\_F9;
  * KEY\_F10;
  * KEY\_F11;
  * KEY\_F12;
  * KEY\_UP;
  * KEY\_DOWN;
  * KEY\_LEFT;
  * KEY\_RIGHT;
  * KEY\_INSERT;
  * KEY\_DELETE;
  * KEY\_HOME;
  * KEY\_END;
  * KEY\_PAGEUP;
  * KEY\_PAGEDOWN;
  * KEY\_CAPS;
  * KEY\_SHIFT;
  * KEY\_CTRL;
  * KEY\_ALT;
  * KEY\_MENU;
  * KEY\_UNKNOWN (system virtual key code = code - KEY\_UNKNOWN).
Константы для функции set\_quit\_action():
  * QA\_NONE;
  * QA\_CLOSE\_VM.

## Многопоточность ##

Флаги (опции) для thread\_create():
  * THREAD\_FLAG\_AUTO\_DESTROY - поток с этим флагом будет удален автоматически после завершения.

## Математические константы ##

  * M\_E - e;
  * M\_LOG2E - log<sub>2</sub>e;
  * M\_LOG10E - log<sub>10</sub>e;
  * M\_LN2 - log<sub>e</sub>2;
  * M\_LN10 - log<sub>e</sub>10;
  * M\_PI - PI;
  * M\_2\_SQRTPI - 2 / sqrt( PI );
  * M\_SQRT2 - sqrt( 2 );
  * M\_SQRT1\_2 - 1 / sqrt( 2 );

## Операции обработки данных ##

Для функции op\_cn():
  * OP\_MIN - `op_cn() return value = min( C1[ i ], C1[ i + 1 ], ... )`;
  * OP\_MAX - `op_cn() return value = max( C1[ i ], C1[ i + 1 ], ... )`;
  * OP\_MAXABS - `op_cn() return value = max( | C1[ i ] + N |, | C1[ i + 1 ] + N |, ... )`;
  * OP\_SUM - сумма элементов; `op_cn() return value = C1[ i ] + C1[ i + 1 ] + ... `
  * OP\_LIMIT\_TOP - `if C1[ i ] > N { C1[ i ] = N } `;
  * OP\_LIMIT\_BOTTOM - `if C1[ i ] < N { C1[ i ] = N } `;
  * OP\_ABS - абсолютное значение;
  * OP\_SUB2 - вычитание с измененным порядком операндов (`N - C1[ i ]`);
  * OP\_COLOR\_SUB2 - то же, что OP\_COLOR\_SUB, но с измененным порядком операндов (`N - C1[ i ]`);
  * OP\_DIV2 - то же, что OP\_DIV, но с измененным порядком операндов (`N / C1[ i ]`);
  * OP\_H\_INTEGRAL - дискретный интеграл (по горизонтали);
  * OP\_V\_INTEGRAL - дискретный интеграл (по вертикали);
  * OP\_H\_DERIVATIVE - дискретная производная (по горизонтали);
  * OP\_V\_DERIVATIVE - дискретная производная (по вертикали);
  * OP\_H\_FLIP;
  * OP\_V\_FLIP.

Для функций op\_cn(), op\_cc():
  * OP\_ADD - сложение;
  * OP\_SADD - сложение с ограничением (защита от переполнения);
  * OP\_COLOR\_ADD - сложение цветов (отдельно складываются значения яркости красного, зеленого и синего) с ограничением;
  * OP\_SUB - вычитание;
  * OP\_SSUB - вычитание с ограничением (защита от переполнения);
  * OP\_COLOR\_SUB - вычитание цветов с ограничением;
  * OP\_MUL - умножение;
  * OP\_SMUL - умножение с ограничением (защита от переполнения);
  * OP\_MUL\_RSHIFT15 - умножение с последующим сдвигом вправо на 15 бит;
  * OP\_COLOR\_MUL - умножение цветов;
  * OP\_DIV - деление;
  * OP\_COLOR\_DIV - деление цветов;
  * OP\_AND - побитовая операция И;
  * OP\_OR - побитовая операция ИЛИ;
  * OP\_XOR - побитовая операция исключающего ИЛИ;
  * OP\_LSHIFT - битовый сдвиг влево;
  * OP\_RSHIFT - битовый сдвиг вправо;
  * OP\_EQUAL;
  * OP\_LESS;
  * OP\_GREATER;
  * OP\_COPY - копирование;
  * OP\_COPY\_LESS - копировать только те элементы, для которых справедливо `C1[ i ] < C2[ i ]`;
  * OP\_COPY\_GREATER - копировать только те элементы, для которых справедливо `C1[ i ] > C2[ i ]`.

Для функции op\_cc():
  * OP\_BMUL - `if C2[ i ] == 0 { C1[ i ] = 0 } `;
  * OP\_EXCHANGE;
  * OP\_COMPARE - сравнение; если сравниваемые участки равны, операция возвращает 0; если первый отличный элемент C1 больше элемента в C2, возвращается 1, если меньше - возвращается -1.

Для функции op\_ccn():
  * OP\_MUL\_DIV - перемножить значения из контейнеров и поделить результат на число;
  * OP\_MUL\_RSHIFT - перемножить значения из контейнеров и сдвинуть результат на указанное кол-во бит вправо.

Для функции generator():
  * OP\_SIN - синус;
  * OP\_SIN8 - быстрый, но менее точный синус (вычисляется по таблице 8-битных значений);
  * OP\_RAND - псевдо-случайные числа (в диапазоне от -amp до +amp).

## Sampler ##

  * SMP\_INFO\_SIZE - размер контейнера с информацией о сэмпле.

Номера ячеек (полей) в контейнере с информацией о сэмпле:
  * SMP\_DEST - номер контейнера, в который будет производиться запись;
  * SMP\_DEST\_OFF - смещение в контейнере для записи;
  * SMP\_DEST\_LEN - длина участка для записи;
  * SMP\_SRC - номер контейнера с сэмплом;
  * SMP\_SRC\_OFF\_H - смещение сэмпла (левая часть числа с фиксированной точкой);
  * SMP\_SRC\_OFF\_L - смещение сэмпла (правая часть числа с фиксированной точкой, от 0 до 65535);
  * SMP\_SRC\_SIZE - размер сэмпла (0 - весь сэмпл);
  * SMP\_LOOP - начало лупа (повторяемого участка сэмпла);
  * SMP\_LOOP\_LEN - длина лупа (или 0, если луп отключен);
  * SMP\_VOL1 - начальная громкость (32768 = 1.0);
  * SMP\_VOL2 - конечная громкость (32768 = 1.0);
  * SMP\_DELTA - дельта (скорость проигрывания); fixed point `(real_value * 65536)`;
  * SMP\_FLAGS - флаги.

Флаги:
  * SMP\_FLAG\_INTERP2 - линейная интерполяция (по двум точкам);
  * SMP\_FLAG\_INTERP4 - кубическая сплайновая интерполяция (по четырем точкам);
  * SMP\_FLAG\_PINGPONG - режим ping-pong для лупа;
  * SMP\_FLAG\_REVERSE - обратное направление проигрывания.

## Константы для нативных вызовов ##

  * CCONV\_DEFAULT;
  * CCONV\_CDECL;
  * CCONV\_STDCALL;
  * CCONV\_UNIX\_AMD64;
  * CCONV\_WIN64.

## Константы для совместимости с POSIX ##

  * FOPEN\_MAX;
  * SEEK\_CUR;
  * SEEK\_END;
  * SEEK\_SET;
  * EOF;
  * STDIN;
  * STDOUT;
  * STDERR.

## Разное ##

  * PIXILANG\_VERSION - версия Pixilang ((major<<24) + (minor<<16) + (minor2<<16) + minor3); например, если версия языка = 3.4.7, то PIXILANG\_VERSION будет 0x03040700;
  * OS\_NAME - контейнер с названием операционной системы, в которой запущен Pixilang (примеры: "ios"; "win32", "linux");
  * ARCH\_NAME - контейнер с названием архитектуры процессора (примеры: "x86", "x86\_64", "arm", "mips");
  * CURRENT\_PATH;
  * USER\_PATH;
  * TEMP\_PATH;
  * OPENGL - 1, если OpenGL доступен; 0 - в противном случае.

# Встроенные глобальные переменные #

  * WINDOW\_XSIZE - ширина пользовательского окна (в пикселях);
  * WINDOW\_YSIZE - высота пользовательского окна (в пикселях);
  * FPS - последнее подсчитанное количество кадров в секунду;
  * PPI - количество пикселей на дюйм;
  * UI\_SCALE - коэффициент масштабирования интерфейса (задан пользователем в глобальных настройках); пример использования: `button_size = PPI * UI_SCALE * 0.5`.

# Зарезервированные свойства контейнера #

Эти свойства могут быть созданы для контейнера после его загрузки командой load():
  * sample\_rate;
  * channels;
  * file\_format;
  * frames - количество кадров;
  * frame - номер текущего кадра;
  * fps - кол-во кадров в секунду;
  * play - состояние автоматического проигрывания (0 - выкл, 1 - вкл); если включено, то кадры будут меняться автоматически во время вызова функции pixi();
  * repeat - количество повторов (-1 - бесконечно);
  * start\_time;
  * start\_frame.

# Встроенные функции #

## Работа с контейнерами ##

### new ###

Создать новый контейнер с данными.

Сразу после создания контейнер может быть заполнен неопределенными значениями. Прежде чем читать из этого контейнера, его следует очистить функцией clean, или заполнить полезными данными.

**Параметры ( xsize, ysize, type )**
  * xsize - ширина.
  * ysize - высота.
  * type - тип контейнера (а точнее - тип элементов, из которых состоит контейнер). Возможны следующие типы:
    * INT - знаковое целое (размер зависит от версии Pixilang);
    * INT8 - знаковое целое (8 бит);
    * INT16 - знаковое целое (16 бит);
    * INT32 - знаковое целое (32 бита);
    * INT64 - знаковое целое (64 бита);
    * FLOAT - плавающая запятая (размер зависит от версии Pixilang);
    * FLOAT32 - плавающая запятая (32 бита);
    * FLOAT64 - плавающая запятая (64 бита);
    * PIXEL - пиксель; после создания контейнера это значение превращается в INTx, где x - кол-во бит на пиксель.

**Возвращаемое значение**

Номер контейнера или -1, если произошла ошибка при создании.

**Примеры**
```
p = new() //Создать контейнер 1x1. Тип = пиксели.
p = new( 4 ) //Создать контейнер 4x1. Тип = пиксели.
p = new( 4, 4 ) //Создать контейнер 4x4. Тип = пиксели.
p = new( 4, 4, FLOAT32 ) //Создать контейнер 4x1. Тип = 32-битные числа с плавающей запятой.
```

### remove ###

Удалить контейнер.

**Параметры ( pixi )**
  * pixi - номер контейнера.

**Примеры**
```
p = new() //Создаем новый контейнер
remove( p ) //Удаляем его
```

### remove\_with\_alpha ###

Удалить контейнер и связанный с ним контейнер альфа-канала (прозрачность).

**Параметры ( pixi )**
  * pixi - номер контейнера.

### resize ###

Изменить параметры контейнера.

**Параметры ( pixi, xsize, ysize, type, flags )**
  * pixi - номер контейнера.
  * xsize - ширина.
  * ysize - высота.
  * type - тип контейнера (а точнее - тип элементов, из которых состоит контейнер). Возможны следующие типы:
    * INT8 - знаковое целое (8 бит);
    * INT16 - знаковое целое (16 бит);
    * INT32 - знаковое целое (32 бита);
    * INT64 - знаковое целое (64 бита);
    * FLOAT32 - плавающая запятая (32 бита);
    * FLOAT64 - плавающая запятая (64 бита);
    * PIXEL - пиксель; после создания контейнера это значение превращается в INTx, где x - кол-во бит на пиксель;
  * flags - опции масштабирования (сочетание флагов RESIZE\_xxx); опциональный.

-1 в любом из параметров будет означать, что данный параметр контейнера остается прежним.

**Возвращаемое значение**

0 - успешно; 1 - ошибка.

**Примеры**
```
p = new() //Создаем новый контейнер 1x1
resize( p, 32 ) //Изменяем его размер на 32x1
remove( p ) //Удаляем контейнер
```

### rotate ###

Перевернуть контейнер на угол angle\*90 градусов.

**Параметры ( pixi, angle )**

### convert\_type ###

Преобразовать значения контейнера к другому типу.

**Параметры ( pixi, new\_type )**

### clean ###

Очистить контейнер (заполнить нулями или указанным значением).

**Параметры ( dest\_cont, v, offset, count )**
  * dest\_cont - номер контейнера;
  * v -  число, которым надо заполнить контейнер; опциональный; по умолчанию - 0;
  * offset - смещение внутри dest\_cont; опциональный; по умолчанию - 0;
  * count - количество элементов, которые нужно заполнить; опциональный; по умолчанию - весь контейнер.

**Примеры**
```
p = new() //Создаем новый контейнер
clean( p ) //Очищаем его
remove( p ) //И удаляем
```

### clone ###

Создать точную копию контейнера.

**Параметры ( pixi )**
  * pixi - номер контейнера.

**Возвращаемое значение**

Номер нового контейнера или -1, если произошла ошибка при создании.

### copy ###

Скопировать данные из контейнера src в контейнер dest.

**Параметры ( dest, src, dest\_offset, src\_offset, count, dest\_step, src\_step, flags )**
  * dest - приемник (куда);
  * src - источник (откуда);
  * dest\_offset - номер первого копируемого элемента в приемнике;
  * src\_offset - номер первого копируемого элемента в источнике;
  * count - количество элементов, которое нужно скопировать;
  * dest\_step - шаг, с которым записываются элементы в приемник (по умолчанию - 1);
  * src\_step - шаг, с которым считываются элементы из источника (по умолчанию - 1).
  * flags - опции (сочетание флагов COPY\_xxx); опциональный.

**Примеры**
```
//Скопировать все элементы из контейнера img1 в img2:
copy( img2, img1 )
//Скопировать элементы 8...200 из контейнера img1 в img2:
copy( img2, img1, 8, 8, 200 )
//Скопировать 200 элементов начиная с 8 из контейнера img1 в img2 с шагом 2:
copy( img2, img1, 8, 8, 200, 2, 2 )
```

**Возвращаемое значение**

Количество элементов, которое удалось успешно скопировать.

### get\_size ###

Получить размер контейнера (кол-во элементов).

**Параметры ( pixi )**
  * pixi - номер контейнера.

**Возвращаемое значение**

Размер контейнера (кол-во элементов).

**Примеры**
```
p = new( 8, 8 ) //Создаем новый контейнер 8x8
size = get_size( p ) //Записываем его размер в переменную size
remove( p ) //Удаляем контейнер
```

### get\_xsize ###

Получить ширину контейнера.

**Параметры ( pixi )**
  * pixi - номер контейнера.

**Возвращаемое значение**

Ширина контейнера.

**Примеры**
```
p = new( 8, 8 ) //Создаем новый контейнер 8x8
xsize = get_xsize( p ) //Записываем его ширину в переменную xsize
remove( p ) //Удаляем контейнер
```

### get\_ysize ###

Получить высоту контейнера.

**Параметры ( pixi )**
  * pixi - номер контейнера.

**Возвращаемое значение**

Высота контейнера.

**Примеры**
```
p = new( 8, 8 ) //Создаем новый контейнер 8x8
ysize = get_xsize( p ) //Записываем его высоту в переменную ysize
remove( p ) //Удаляем контейнер
```

### get\_esize ###

Получить размер элемента контейнера (в байтах).

**Параметры ( pixi )**
  * pixi - номер контейнера.

**Возвращаемое значение**

Размер элемента контейнера (в байтах).

**Примеры**
```
p = new( 8, 8, INT16 ) //Создаем новый контейнер 8x8; тип элемента = INT16
esize = get_esize( p ) //Записываем размер его элемента в переменную esize
//Теперь в переменной esize находится число 2 (т.к. 16 бит - это два байта).
remove( p ) //Удаляем контейнер
```

### get\_type ###

Получить тип элемента контейнера.

**Параметры ( pixi )**
  * pixi - номер контейнера.

**Возвращаемое значение**

Тип элемента контейнера.

**Примеры**
```
p = new( 8, 8, INT32 ) //Создаем новый контейнер 8x8; тип элемента = INT32
type = get_type( p ) //Записываем тип его элемента в переменную type
//Теперь в переменной type находится константа INT32.
remove( p ) //Удаляем контейнер
```

### get\_flags ###

Получить флаги контейнера. Под флагами подразумевается 32-битное число, каждый бит в котором отвечает за включение/выключение какой-то опции контейнера.
Полный список флагов можно посмотреть в разделе [Флаги (опции) контейнера](http://code.google.com/p/pixilang/wiki/PixilangV3Manual_RU#Флаги_(опции)_контейнера).

**Параметры ( pixi )**
  * pixi - номер контейнера.

**Возвращаемое значение**

Флаги контейнера.

### set\_flags ###

Установить флаги контейнера. Под флагами подразумевается 32-битное число, каждый бит в котором отвечает за включение/выключение какой-то опции контейнера.
Полный список флагов можно посмотреть в разделе [Флаги (опции) контейнера](http://code.google.com/p/pixilang/wiki/PixilangV3Manual_RU#Флаги_(опции)_контейнера).

**Параметры ( pixi, flags )**
  * pixi - номер контейнера;
  * flags - флаги.

**Примеры**
```
set_flags( img, GL_MIN_LINEAR | GL_MAG_LINEAR )
```

### reset\_flags ###

Сбросить флаги контейнера.

**Параметры ( pixi, flags )**
  * pixi - номер контейнера;
  * flags - флаги.

### get\_prop ###

Получить значение свойства контейнера. У каждого контейнера может быть неограниченное количество свойств.

Другой путь получения свойства контейнера - использовать оператор . (точка). Например: value = image.fps

**Параметры ( pixi, prop\_name, def\_prop )**
  * pixi - номер контейнера;
  * prop\_name - имя свойства;
  * def\_prop - это значение возвратится функцией, если свойство не существует; опциональный.

**Возвращаемое значение**

Числовое значение указанного свойства контейнера.

### set\_prop ###

Установить значение свойства контейнера.

Другой путь установки свойства контейнера - использовать оператор . (точка). Например: image.fps = 20

**Параметры ( pixi, prop\_name, value )**
  * pixi - номер контейнера;
  * prop\_name - имя свойства;
  * value - числовое значение.

**Примеры**
```
p = new( 8, 8, INT32 ) //Создаем новый контейнер 8x8; тип элемента = INT32
set_prop( p, "speed", 777 ) //Добавляем свойство "speed" у созданного контейнера
v = get_prop( p, "speed" ) //Читаем значение этого свойства
//Теперь в переменной v лежит число 777
//Рассмотрим так же более простой способ работы со свойствами контейнера
//(при помощи оператора . (точка)):
p.speed = 777
v = p.speed
```

### remove\_props ###

Удалить все свойства контейнера.

**Параметры ( pixi )**

### show\_memory\_debug\_messages ###

Включить/выключить отладочные сообщения менеджера управления памятью.

**Параметры ( enable )**

### zlib\_pack ###

Запаковать контейнер библиотекой Zlib.

**Параметры ( source, level )**
  * source - контейнер, который будет запакован;
  * level - уровень компрессии Zlib (Z\_NO\_COMPRESSION, Z\_BEST\_SPEED, Z\_BEST\_COMPRESSION, Z\_DEFAULT\_COMPRESSION); опциональный.

**Возвращаемое значение**

Номер нового контейнера, который является запакованной копией source. Или -1 в случае ошибки.

### zlib\_unpack ###

Распаковать контейнер библиотекой Zlib.

**Параметры ( source )**
  * source - контейнер, который будет распакован.

**Возвращаемое значение**

Номер нового контейнера, который является распакованной копией source. Или -1 в случае ошибки.

## Текстовые строки ##

### num\_to\_str ###

Альтернативные имена: num2str.

Конвертировать число из переменной в текстовую строку (в контейнер).

**Параметры ( str, num )**
  * str - контейнер для строки;
  * num - число.

**Примеры**
```
v = 45.64
s = ""
num_to_str( s, v )
fputs( s ) fputs( "\n" )
```

### str\_to\_num ###

Альтернативные имена: str2num.

Конвертировать текста (из контейнера) в число.

**Параметры ( str )**
  * str - контейнер со строкой.

**Возвращаемое значение**

Числовое значение.

**Примеры**
```
a = str_to_num( "-55.44" )
b = a + 4
```

### strcat ###

Добавляет строку source к строке destination. Обе строки должны заканчиваться символом с кодом 0, если кол-во остальных символов в строке меньше размера контейнера, в котором строка находится. После выполнения этой функции размер контейнера destination может увеличиться, если в нем не хватит места для строки source.

**Параметры ( destination, source )**

**Параметры ( dest, dest\_offset, source, source\_offset )**

### strcmp ###

Сравнивает две строки str1 и str2. Обе строки должны заканчиваться символом с кодом 0, если кол-во остальных символов в строке меньше размера контейнера, в котором строка находится.

**Параметры ( str1, str2 )**

**Параметры ( str1, str1\_offset, str2, str2\_offset )**

**Возвращаемое значение**

  * Меньше нуля - str1 меньше str2.
  * Больше нуля - str1 больше str2.
  * 0 - str1 равна str2.

### strlen ###

Возвращает длину строки. Завершающий символ с кодом 0 не учитывается. Строки должна заканчиваться символом с кодом 0, если кол-во остальных символов в строке меньше размера контейнера, в котором строка находится.

**Параметры ( str )**

**Параметры ( str, str\_offset )**

**Возвращаемое значение**

Длина строки.

### strstr ###

Ищет первое вхождение подстроки str2 в строке str1. Обе строки должны заканчиваться символом с кодом 0, если кол-во остальных символов в строке меньше размера контейнера, в котором строка находится.

**Параметры ( str1, str2 )**

**Параметры ( str1, str1\_offset, str2, str2\_offset )**

**Возвращаемое значение**

Функция возвращают смещение подстроки str2 в строке str1, или -1, если подстрока не найдена.

### sprintf ###

Форматирует и запоминает наборы символов и значений в str. Каждый аргумент (если он есть), преобразуется и выводится согласно соответствующей спецификации формата в format. Подробное описание формата можно почитать здесь: http://ru.wikipedia.org/wiki/Printf или в любой документации на функцию sprintf() языка Си/Си++. Контейнер str расширяется при необходимости.

**Параметры ( str, format, ... )**

**Возвращаемое значение**

Возвращает количество символов, записанных в str. В случае ошибки возвращается отрицательное значение.

**Примеры**
```
sprintf( str, "Some text" ) //Записать текст в контейнер str
//В результате контейнер str будет содержать следующую строку: "Some text"
sprintf( str, "Number: %d", 12 ) //Записать знаковое десятичное число
//В результате контейнер str будет содержать следующую строку: "Number: 12"
```

### printf ###

То же самое, что sprintf, только результат (набор символов и значений) записывается в поток STDOUT.

**Параметры ( format, ... )**

### fprintf ###

Форматный вывод текста в указанный поток (открытый функцией fopen() или fopen\_mem()).

**Параметры ( stream, format, ... )**

## Работа с логом (журналом событий) ##

### logf ###

Форматный вывод текста в буфер для логов (журнал событий).

**Параметры ( format, ... )**

### get\_log ###

Получить буфер с логом (журнал событий).

**Возвращаемое значение**

Номер нового контейнера, в котором лежит свежий лог. Этот контейнер нужно удалять вручную!

### get\_system\_log ###

Получить буфер с системным логом (журнал событий). Системный лог содержит сообщения от всех виртуальных машин Pixilang и различных системных функций (глобальная инициализация Pixilang).

**Возвращаемое значение**

Номер нового контейнера, в котором лежит свежий лог. Этот контейнер нужно удалять вручную!

## Работа с файлами ##

### load ###

Загрузить контейнер из файла.

**Параметры ( filename, options )**

**Возвращаемое значение**

Номер загруженного контейнера, или -1 в случае ошибки.

**Примеры**
```
//Грузим файл:
c = load( "smile.jpg" )
if c >= 0
{
  //Получаем формат загруженного файла:
  file_format = c.file_format
  //Возможные значения переменной file_format:
  //  FORMAT_RAW;
  //  FORMAT_JPEG;
  //  FORMAT_PNG;
  //  FORMAT_GIF;
  //  FORMAT_WAVE;
  //  FORMAT_AIFF;
  //  FORMAT_PIXICONTAINER;
  //  или еще какое-то из раздела "Типы файлов".
}
```

### fload ###

Загрузить контейнер из потока данных, открытого функцией fopen() или fopen\_mem().

**Параметры ( stream, options )**

**Возвращаемое значение**

Номер загруженного контейнера, или -1 в случае ошибки.

### save ###

Сохранить контейнер в указанном формате.

**Параметры ( pixi, filename, format, options )**
  * pixi;
  * filename;
  * format (FORMAT\_RAW, FORMAT\_JPEG, FORMAT\_PNG, FORMAT\_GIF, FORMAT\_WAVE, FORMAT\_PIXICONTAINER);
  * options - опции (необязательный параметр):
    * для JPEG: качество сжатия от 0 (наихудшее) до 100 (наилучшее);
    * для GIF: сочетание флагов GIF\_GRAYSCALE, GIF\_DITHER.

**Возвращаемое значение**

0 в случае успешного сохранения.

**Примеры**
```
c = load( "smile.jpg" )
save( c, "smile.png", FORMAT_PNG )
save( c, "smile2.jpg", FORMAT_JPEG ) //Quality = 85 (default)
save( c, "smile3.jpg", FORMAT_JPEG, 100 ) //Quality = 100
```

### fsave ###

Сохранить контейнер в поток данных, открытый функцией fopen() или fopen\_mem().

**Параметры ( pixi, stream, format, options )**

**Возвращаемое значение**

0 в случае успешного сохранения.

### get\_real\_path ###

Преобразовать путь в стиле Pixilang (например, 1:/img.png) в стиль реальной файловой системы (например, C:/Documents and Settings/username/Application Data/img.png).

**Параметры ( path )**

**Возвращаемое значение**

Текстовый контейнер с новым именем файла. Должен быть освобожден при помощи remove().

**Examples**
```
filename = "1:/some_file"
realpath = get_real_path( filename )
printf( "File name: %s; Real path: %s\n", filename, realpath )
remove( realpath )
```

### new\_flist ###
### remove\_flist ###
### get\_flist\_name ###
### get\_flist\_type ###
### flist\_next ###

Функции для получения списка файлов.

**Примеры**
```
path = CURRENT_PATH //Директория, в которой мы будем сканировать файлы.
mask = -1 //Примеры маски: "txt/doc", "avi"; или -1 для получения всех файлов.
fl = new_flist( path, mask )
if fl >= 0
{
  printf( "Some files found in %s\n", path )
  while( 1 )
  {
    file_name = get_flist_name( fl )
    file_type = get_flist_type( fl ) //0 - файл; 1 - директория;
    if file_type == 0
    {
      printf( "FILE %s%s\n", path, file_name )
    }
    else
    {
      printf( "DIR  %s%s\n", path, file_name )
    }
    if flist_next( fl ) == 0 //Переходим к следующему файлу
    {
      //Файлов больше нет
      break
    }
  }
  remove_flist( fl )
}
```

### get\_file\_size ###

Получить размер файла.

**Параметры ( filename )**

### remove\_file ###

**Параметры ( filename )**

### rename\_file ###

**Параметры ( old\_filename, new\_filename )**

### copy\_file ###

Скопировать файл из source\_filename в destination\_filename.

**Параметры ( source\_filename, destination\_filename )**

### create\_directory ###

Создать директорию.

**Параметры ( directory\_name, mode )**
  * directory\_name - имя создаваемой директории;
  * mode - режим доступа (только для тех систем, где это поддерживается); опциональный.

### set\_disk0 ###

Использовать поток данных _stream_ (открытый функцией fopen() или fopen\_mem()) как виртуальный диск 0:/ .
При этом _stream_ должен указывать на открытый незапакованный TAR архив. Файлы внутри TAR архива будут доступны для всех файловых функций через обращение к диску 0:/.

**Параметры ( stream )**
  * stream - поток данных, или 0, если вы хотите выключить диск 0:/

### get\_disk0 ###

### fopen ###

**Параметры ( filename, mode )**

**Возвращаемое значение**

Поток данных, связанный с указанным файлом. Или 0 в случае ошибки.

**Примеры**
```
f = fopen( "/tmp/data.txt", "rb" ) //Открываем файл data.txt для чтения
fclose( f ) //...и закрываем его.
```

### fopen\_mem ###

Открыть контейнер _data_ как файл.

**Параметры ( data )**

**Возвращаемое значение**

Поток данных, связанный с указанным контейнером. Или 0 в случае ошибки.

### fclose ###

**Параметры ( stream )**

**Примеры**
```
f = fopen( "/tmp/data.txt", "rb" ) //Открываем файл data.txt для чтения.
c = fgetc( f ) //Получаем байт из этого файла.
fclose( f ) //Закрываем файл.
```

### fputc ###

**Параметры ( c, stream )**

**Примеры**
```
f = fopen( "/tmp/data.txt", "wb" ) //Открываем файл data.txt для записи.
fputc( 0x12, f ) //Записываем байт 0x12 в этот файл.
fclose( f ) //Закрываем файл.
```

### fputs ###

**Параметры ( s, stream )**

**Примеры**
```
f = fopen( "/tmp/data.txt", "wb" ) //Открываем файл data.txt для записи.
str = "Hello!"
fputc( str, f ) //Записываем строку "Hello!" в этот файл.
fclose( f ) //Закрываем файл.
```

### fwrite ###

**Параметры ( data, size, stream, data\_offset\_optional )**

**Примеры**
```
f = fopen( "/tmp/data.txt", "wb" ) //Открываем файл data.txt для записи.
str = "Hello!"
fwrite( str, 2, f ) //Записываем первые два байта из контейнера str в этот файл.
fclose( f ) //Закрываем файл.
```

### fgetc ###

**Параметры ( stream )**

### fgets ###

Загрузить строку текста из потока stream.

**Параметры ( s, n, stream, offset )**

**Возвращаемое значение**

Длина полученной строки.

**Примеры**
```
string = new( 256, 1, INT8 )
f = fopen( "/tmp/data.txt", "rb" ) //Открываем файл data.txt для чтения.
fgets( string, 256, f ) //Получаем строку текста из этого файла.
//Полученная строка помещается в указанный выше контейнер string.
//Если в контейнере недостаточно места, то строка обрезается.
fclose( f ) //Закрываем файл.
```

### fread ###

Загрузить блок данных из потока stream.

**Параметры ( data, size, stream, data\_offset\_optional )**

### feof ###

**Параметры ( stream )**

### fflush ###

**Параметры ( stream )**

### fseek ###

**Параметры ( stream, offset, origin )**

### ftell ###

**Параметры ( stream )**

**Примеры**
```
//Один из способов получения размера файла:
f = fopen( "/tmp/data.txt", "rb" )
fseek( f, 0, SEEK_END )
size_of_file = ftell( f )
fclose( f )
```

### setxattr ###

Установить значение одного из дополнительных атрибутов файла.

**Параметры ( path, attr\_name, data, data\_size\_in\_bytes, flags )**

**Возвращаемое значение**

0 в случае успешного завершения, или -1 в случае ошибки.

## Графика ##

### frame ###

Вывести содержимое рабочего экрана на дисплей и подождать указанное количество миллисекунд.

**Параметры ( delay, x, y, xsize, ysize )**
  * delay - длина паузы (в миллисекундах), которую нужно выждать после вывода на экран. По разным причинам пауза может оказаться длиннее, например, если система притормозила, или в системе неточный таймер;
  * x, y, xsize, ysize - необязательные параметры, указывающие, какой регион текущего экрана надо вывести.

**Возвращаемое значение**

  * 0 - успешное завершение;
  * -1 - контейнер рабочего экрана не найден;
  * -2 - тайм-аут (возможно, графический движок временно не работает).

### vsync ###

Включить/выключить вертикальную синхронизацию (синхронизация кадровой частоты с частотой вертикальной развёртки монитора).
vsync(1) - включить. vsync(0) - выключить.

**Параметры ( enable )**

### set\_screen ###

Сделать указанный контейнер текущим рабочим экраном. Номер контейнера с экраном по умолчанию - 0.

**Параметры ( pixi )**
  * pixi - номер контейнера.

### get\_screen ###

Получить номер контейнера, который в данный момент является рабочим экраном.

**Возвращаемое значение**

Номер контейнера, который является рабочим экраном.

### set\_zbuf ###

**Параметры ( zbuf\_container )**

Указать контейнер, который будет буфером глубины (Z-Buffer) при рисовании трехмерных объектов. Подробнее про Z-буферизацию [можно почитать здесь](http://ru.wikipedia.org/wiki/Z-%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F).

Контейнер должен иметь тип INT32 и по размерам совпадать с размером текущего экрана.

### get\_zbuf ###

### clear\_zbuf ###

### get\_color ###

Получить значение цвета с заданными характеристиками r,g,b (красный,зеленый,синий).

**Параметры ( red, green, blue )**
  * red - интенсивность красного (от 0 до 255);
  * green - интенсивность зеленого (от 0 до 255);
  * blue - интенсивность синего (от 0 до 255);

**Возвращаемое значение**

Значение цвета. Формат этого значения может меняться в зависимости от версии Pixilang. Например, если Pixilang скомпилирован для устройств с 8-битным дисплеем, то значение цвета будет в диапазоне от 0 до 255.

### get\_red ###

Получить интенсивность красной составляющей в указанном цвете.

**Параметры ( color )**
  * color - цвет.

**Возвращаемое значение**

Интенсивность красной составляющей. От 0 до 255.

### get\_green ###

Получить интенсивность зеленой составляющей в указанном цвете.

**Параметры ( color )**
  * color - цвет.

**Возвращаемое значение**

Интенсивность зеленой составляющей. От 0 до 255.

### get\_blue ###

Получить интенсивность синей составляющей в указанном цвете.

**Параметры ( color )**
  * color - цвет.

**Возвращаемое значение**

Интенсивность синей составляющей. От 0 до 255.

### get\_blend ###

Получить промежуточное значение цвета между двумя известными.

**Параметры ( c1, c2, v )**
  * c1 - первый цвет;
  * с2 - второй цвет;
  * v - положение между c1 и c2; 0 - ближе всего к c1; 255 - ближе всего к c2.

**Возвращаемое значение**

Промежуточное значение цвета.

### transp ###

Установить прозрачность для всех последующих функций.

**Параметры ( t )**
  * t - значение прозрачности от 0 (невидимый) до 255 (непрозрачный).

### get\_transp ###

Получить текущее значение прозрачности.

### clear ###

Очистить текущий рабочий экран заданным цветом (или черным, если цвет не задан).

**Параметры ( color )**
  * color - цвет.

### dot ###

Нарисовать точку.

**Параметры ( x, y, color )**
  * x - координата X;
  * y - координата Y;
  * color - цвет.

### dot3d ###

Нарисовать точку в 3D.

**Параметры ( x, y, z, color )**

### get\_dot ###

Получить цвет в указанной точке.

**Параметры ( x, y )**
  * x - координата X;
  * y - координата Y.

**Возвращаемое значение**

Значение цвета в указанной точке.

### get\_dot3d ###

Получить цвет в указанной точке.

**Параметры ( x, y, z )**

**Возвращаемое значение**

Значение цвета в указанной точке.

### line ###

Нарисовать линию.

**Параметры ( x1, y1, x2, y2, color )**

### line3d ###

Нарисовать линию в 3D.

**Параметры ( x1, y1, z1, x2, y2, z2, color )**

### box ###

Нарисовать прямоугольник.

**Параметры ( x, y, xsize, ysize, color )**

### fbox ###

Нарисовать закрашенный прямоугольник.

**Параметры ( x, y, xsize, ysize, color )**

### pixi ###

Вывести на экран контейнер с картинкой.

**Параметры ( pixi\_cont, x, y, color, xscale, yscale, src\_x, src\_y, src\_xsize, src\_ysize )**
  * pixi\_cont - номер контейнера с картинкой;
  * x;
  * y;
  * color - цвет фильтра; опциональный; значение по умолчанию - WHITE (пропускаются все цвета);
  * xscale - коэффициент масштабирования по оси X; опциональный; значение по умолчанию - 1;
  * yscale - коэффициент масштабирования по оси Y; опциональный; значение по умолчанию - 1;
  * src\_x - смещение по оси X внутри контейнера pixi\_cont; по умолчанию - 0;
  * src\_y - смещение по оси Y внутри контейнера pixi\_cont; по умолчанию - 0;
  * src\_xsize - ширина области (внутри контейнера), которую нужно вывести на экран; по умолчанию равна ширине контейнера;
  * src\_ysize - высота области (внутри контейнера), которую нужно вывести на экран; по умолчанию равна высоте контейнера.

**Примеры**
```
pixi( image )
pixi( image, 10, 20 )
pixi( image, 30, 40, GREEN )
pixi( image, 90, 20, GREEN, 0.5, 0.5 )
```

### triangles3d ###

Нарисовать массив треугольников.

**Параметры ( vertices, triangles )**
  * vertices - контейнер вершин; ширина контейнера = 8; высота контейнера = количество вершин; формат одной вершины: `X, Y, Z, TextureX (от 0 до ширины текстуры), TextureY (от 0 до высоты текстуры), Unused, Unused, Unused`;
  * triangles - контейнер треугольников; ширина контейнера = 8; высота контейнера = количество треугольников; формат треугольника: `NumberOfVertex1, NumberOfVertex2, NumberOfVertex3, Color, Texture (или -1), Transparency (0..255), Unused, Order (треугольники с малыми значениями Order будут рисоваться раньше остальных)`.

### sort\_triangles3d ###

Отсортировать массив треугольников по глубине так, чтобы при вызове triangles3d() сначала рисовались дальние треугольники, а потом ближние.

**Параметры ( vertices, triangles )**

### set\_key\_color ###

Установить/сбросить цвет прозрачности у контейнера.

**Параметры ( pixi, color )**
  * pixi - номер контейнера;
  * color - цвет, который будет прозрачным; если цвет не указать, прозрачность для контейнера pixi выключится.

### get\_key\_color ###

### set\_alpha ###

Привязать к контейнеру другой контейнер с альфа-каналом. Альфа-канал должен иметь тип INT8.

**Параметры ( cont, alpha )**
  * cont - номер контейнера;
  * alpha - номер контейнера с альфа-каналом; если этот параметр не указать, то альфа-канал выключится для контейнера pixi.

### get\_alpha ###

Получить номер контейнера с альфа-каналом, привязанного к указанному контейнеру.

**Параметры ( cont )**

**Возвращаемое значение**

Номер контейнера или -1 (если альфа-канал отсутствует).

### print ###

Вывести текст на экран.

**Параметры ( text, x, y, color, align, max\_xsize )**
  * text - номер контейнера с текстом;
  * x, y - координаты точки, относительно которой происходит выравнивание;
  * color - цвет;
  * align - выравнивание;
  * max\_xsize - максимальный размер (кол-во пикселей) текста по горизонтали; опциональный.

**Примеры**
```
print( "Hello Pixi!", 0, 0 ) //цвет - белый; выравнивание - по центру;
print( "line1\nline2", 50, 50, RED ) //выравнивание - по центру;
print( "line1\nline2", -50, 50, RED, TOP | LEFT ) //выравнивание - по верхнему левому краю;
```

### get\_text\_xsize ###

**Параметр ( text, align, max\_xsize )**
  * text - номер контейнера с текстом;
  * align - выравнивание;
  * max\_xsize - максимальный размер (кол-во пикселей) текста по горизонтали; опциональный.

**Возвращаемое значение**

Ширина текста в пикселях.

### get\_text\_ysize ###

**Параметр ( text, align, max\_xsize )**
  * text - номер контейнера с текстом;
  * align - выравнивание;
  * max\_xsize - максимальный размер (кол-во пикселей) текста по горизонтали; опциональный.

**Возвращаемое значение**

Высота текста в пикселях.

### set\_font ###

**Параметры ( first\_char\_utf32, font\_image, xchars, ychars )**

### get\_font ###

**Параметры ( char\_utf32 )**

**Возвращаемое значение**

Номер контейнера, в котором находится картинка шрифта для указанного символа.

### effector ###

Наложить эффект на выделенный участок экрана. На координаты этой функции не действует трансформация.

**Параметры ( type, power, color, x, y, xsize, ysize, x\_step, y\_step )**

### color\_gradient ###

Нарисовать цветной градиент в указанном прямоугольнике. На координаты этой функции не действует трансформация.

**Параметры ( color1, transp1, color2, transp2, color3, transp3, color4, transp4, x, y, xsize, ysize, x\_step, y\_step )**

### split\_rgb ###

Разбить картинку по каналам (красный, зеленый, синий) или наоборот собрать.
Канал в данном случае - это контейнер любого типа, в который будут записываться (или считываться) значения яркости красной, зеленой или синей составляющей изображения.

**Параметры ( direction, image, red\_channel, green\_channel, blue\_channel, image\_offset, channel\_offset, size )**
  * direction: 0 - ковертация из image в RGB; 1 - конвертация из RGB в image;
  * image - контейнер с картинкой (тип PIXEL);
  * red\_channel - контейнер со значениями красного; опциональный; может быть -1, если нужно игнорировать этот канал;
  * green\_channel - контейнер со значениями зеленого; опциональный; может быть -1, если нужно игнорировать этот канал;
  * blue\_channel - контейнер со значениями синего; опциональный; может быть -1, если нужно игнорировать этот канал;
  * image\_offset - смещение в контейнере image; опциональный;
  * channel\_offset - смещение в контейнерах с каналами; опциональный;
  * size - количество пикселей; опциональный.

**Примеры**
```
img = load( "some_image.jpg" )
xsize = get_xsize( img )
ysize = get_ysize( img )
r = new( xsize, ysize, INT16 )
g = new( xsize, ysize, INT16 )
b = new( xsize, ysize, INT16 )
split_rgb( 0, img, r, g, b ) //Разбиваем картинку img на составляющие r, g, b
//Получаем яркость красного (от 0 до 255) для первого пикселя изображения:
value = r[ 0 ]
```

### split\_ycbcr ###

Аналогична split\_rgb(), только для преобразования в/из формата YCbCr.

## OpenGL функции ##

### set\_gl\_callback ###

Установить gl\_callback - функцию, которая будет отвечать за OpenGL-отрисовку кадра.

**Параметры ( gl\_callback, user\_data )**
  * gl\_callback - функция с параметрами ($user\_data); почти все графические функции внутри gl\_callback() будут выполняться через OpenGL, в обход стандартного пиксельного движка Pixilang;
  * user\_data - какие-то пользовательские данные, которые будут переданы функции gl\_callback() во время перерисовки кадра.

**Примеры**
```
fn gl_callback( $user_data )
{
  set_screen( GL_SCREEN ) //Включить режим рисования в буфер OpenGL
  clear( YELLOW )
  set_screen( 0 ) //Возвращаемся в обычный режим рисования
}

set_gl_callback(
  gl_callback,
  0 )

while( 1 ) 
{ 
  while( get_event() ) { if EVT[ EVT_TYPE ] == EVT_QUIT { break2 } }
  frame() 
}

set_gl_callback( -1 ) //Удалить gl_callback
```

### remove\_gl\_data ###

Удалить из контейнера все OpenGL данные, которые были созданы автоматически во время перерисовки OpenGL кадра внутри gl\_callback().

**Параметры ( container )**

### gl\_draw\_arrays ###

Гибрид OpenGL функций glColor4ub(), glBindTexture(), glVertexPointer(), glColorPointer(), glTexCoordPointer(), glDrawArrays().

**Параметры ( mode, first, count, color\_r, color\_g, color\_b, color\_a, texture, vertex\_array, color\_array, texcoord\_array )**
  * mode - режим рисования:
    * GL\_POINTS;
    * GL\_LINE\_STRIP;
    * GL\_LINE\_LOOP;
    * GL\_LINES;
    * GL\_TRIANGLE\_STRIP;
    * GL\_TRIANGLE\_FAN;
    * GL\_TRIANGLES;
  * first - номер первой вершины в указанных массивах;
  * count - количество вершин;
  * color\_r, color\_g, color\_b, color\_a - цвет RGBA (только, если не задан color\_array);
  * texture - контейнер с текстурой, или -1;
  * vertex\_array - контейнер типа INT8, INT16 или FLOAT32 с вершинами;
  * color\_array - контейнер типа INT8 или FLOAT32 с RGBA цветами вершин, или -1; опциональный;
  * texcoord\_array - контейнер типа INT8, INT16 или FLOAT32 с текстурными координатами; опциональный.

### gl\_blend\_func ###

Полный аналог OpenGL функции glBlendFunc().

**Параметры ( sfactor, dfactor )**

### gl\_bind\_framebuffer ###

Превратить указанный контейнер cnum в OpenGL framebuffer (с прикрепленной текстурой) и сделать его текущим - то есть, все последующие операции рисования отправлять не на экран, а в этот framebuffer.
Для отключения и перехода обратно на основной экран - вызовите эту функцию без параметров.

**Параметры ( cnum )**

## Анимация контейнеров ##

### pack\_frame ###

Запаковать текущее содержимое контейнера в кадр. Номер кадра должен быть в свойстве "frame" этого контейнера.

**Параметры ( pixi )**

### unpack\_frame ###

Распаковать кадр в текущее содержимое контейнера. Номер кадра должен быть в свойстве "frame" этого контейнера.

**Параметры ( pixi )**

### create\_anim ###

Создать анимацию - скрытую область контейнера, в которой будут располагаться запакованные кадры.

**Параметры ( pixi )**

### remove\_anim ###

Удалить анимацию в указанном контейнере.

**Параметры ( pixi )**

### clone\_frame ###

Продублировать текущий кадр в указанном контейнере. Номер кадра должен быть в свойстве "frame" этого контейнера.

**Параметры ( pixi )**

### remove\_frame ###

Удалить текущий кадр в указанном контейнере. Номер кадра должен быть в свойстве "frame" этого контейнера.

**Параметры ( pixi )**

### play ###

Включить режим авто-проигрывания для указанного контейнера. В этом режиме нужные кадры будут распаковываться автоматически во время вызова функции pixi().

**Параметры ( pixi )**

### stop ###

Выключить режим авто-проигрывания для указанного контейнера.

**Параметры ( pixi )**

## Трансформация ##

Трансформация системы координат.

### t\_reset ###

Сброс (очистка текущей матрицы трансформации).

### t\_rotate ###

**Параметры ( angle, x, y, z )**
  * angle - угол поворота в градусах;
  * x, y, z - координаты вектора, задающего ось поворота.

### t\_translate ###

**Параметры ( x, y, z )**

### t\_scale ###

**Параметры ( x, y, z )**

### t\_push\_matrix ###

Сохранить текущую матрицу трансформации в стек.

### t\_pop\_matrix ###

Загрузить последнюю сохраненную матрицу трансформации из стека.

### t\_get\_matrix ###

Получить текущую матрицу трансформации (4x4 FLOAT).

**Параметры ( matrix\_container )**

### t\_set\_matrix ###

Установить текущую матрицу трансформации (4x4 FLOAT).

**Параметры ( matrix\_container )**

### t\_mul\_matrix ###

`Current matrix = current matrix * matrix_container`

**Параметры ( matrix\_container )**

### t\_point ###

Пересчитать координаты точки с учетом текущей матрицы трансформации.

**Параметры ( point\_coordinates )**
  * point\_coordinates - контейнер с тремя элементами типа FLOAT.

## Звук ##

### set\_audio\_callback ###

Задать функцию, которая будет генерировать звуковой поток.

**Параметры ( callback, userdata, freq, format, channels, flags )**

**Примеры**
```
fn audio_callback( $stream, $userdata, $channels, $frames, $time )
{
  generator( OP_SIN, $channels[ 0 ], 0, 32767 / 2, 0.1, 0 ) //Левый канал
  generator( OP_SIN, $channels[ 1 ], 0, 32767 / 2, 0.1, 0 ) //Правый канал
  ret(1)
}
//Запустить звук:
set_audio_callback( audio_callback, 0, 22050, INT16, 2, AUDIO_FLAG_INTERP2 )
```
```
//Остановить звук:
set_audio_callback( -1 )
```

### enable\_audio\_input ###

**Параметры ( disable\_enable )**

### get\_note\_freq ###

**Параметры ( note, finetune )**
  * note - номер ноты; 0 = C-0; 1 = C#0; 2 = D-0 ...
  * finetune - подстройка от -64 (предыдущая нота) до 64 (следующая нота).

**Возвращаемое значение**

Частота ноты в Герцах.

## MIDI ##

### midi\_open\_client ###

**Параметры ( client\_name )**

**Возвращаемое значение**

ID клиента.

### midi\_close\_client ###

**Параметры ( client\_id )**

### midi\_get\_device ###

**Параметры ( client\_id, device\_num, flags )**

**Возвращаемое значение**

Имя устройства под номером device\_num, или -1, если нет такого устройства.

### midi\_open\_port ###

**Параметры ( client\_id, port\_name, device\_name, flags )**

**Возвращаемое значение**

Номер открытого порта (port ID).

### midi\_reopen\_port ###

**Параметры ( client\_id, port\_id )**

### midi\_close\_port ###

**Параметры ( client\_id, port\_id )**

### midi\_get\_event ###

**Параметры ( client\_id, port\_id, data\_cont )**

**Возвращаемое значение**

Размер (в байтах) текущего MIDI события.

### midi\_get\_event\_time ###

**Параметры ( client\_id, port\_id )**

**Возвращаемое значение**

Время (в системных тиках) текущего MIDI события

### midi\_next\_event ###

Перейти на следующее сообщения в очереди.

**Параметры ( client\_id, port\_id )**

### midi\_send\_event ###

**Параметры ( client\_id, port\_id, data\_cont, data\_size, t )**

## Время ##

### start\_timer ###

Запустить таймер.

**Параметры ( timer\_num )**
  * timer\_num - номер таймера.

### get\_timer ###

Получить значение таймера в миллисекундах.

**Параметры ( timer\_num )**
  * timer\_num - номер таймера.

**Возвращаемое значение**

32-битное значение таймера в миллисекундах.

### get\_year ###

### get\_month ###

### get\_day ###

### get\_hours ###

### get\_minutes ###

### get\_seconds ###

### get\_ticks ###

Получить значение системного 32-битного таймера высокого разрешения. Единица измерения - 1 тик.

### get\_tps ###

Получить количество системных тиков в секунду.

### sleep ###

Заснуть на указанный промежуток времени.

**Параметры ( delay )**
  * delay - длина задержки в миллисекундах.

## События ##

### get\_event ###

Получить очередное событие от системы.

**Возвращаемое значение**

0 - нет новых событий. 1 - очередное событие получено и оно находится в контейнере EVT.

### set\_quit\_action ###

Установить поведение программы при получении события EVT\_QUIT.

**Параметры ( action )**
  * action - номер действия, которое нужно выполнять при получении события EVT\_QUIT.

Возможные значения параметра action:
  * QA\_NONE - ничего не делать;
  * QA\_CLOSE\_VM (по умолчанию) - закрыть текущую виртуальную машину, но не выходить из Pixilang.

## Многопоточность ##

### thread\_create ###

Создать новый поток выполнения, в котором сразу после создания будет запущена функция thread\_function( $thread\_id, $user\_data )

**Параметры ( thread\_function, user\_data, flags\_optional )**

**Возвращаемое значение**

ID потока или -1 в случае ошибки.

**Примеры**
```
fn thread_body( $thread_id, $user_data )
{
  printf( "Thread code\n" )
}
thread_id = thread_create( thread_body, 0 ) //Создаем новый поток
err = thread_destroy( thread_id, 1000 ) //Ждем до 1000 миллисекунд, пока поток завершится
if err == 0 { printf( "Поток успешно завершен и закрыт\n" ) }
if err == 1 { printf( "Тайм-аут. Стоит попробовать еще раз\n" ) }
if err == 2 { printf( "Возникла ошибка в функции thread_destroy()\n" ) }
```

### thread\_destroy ###

Закрыть поток выполнения.

**Параметры ( thread\_id, timeout\_ms )**
  * thread\_id;
  * timeout\_ms - тайм-аут в миллисекундах; отрицательные значения - не пытаться закрыть поток (небезопасно) в случае тайм-аута; INT\_MAX - бесконечное ожидание.

**Возвращаемое значение**

  * 0 - поток успешно закрыт;
  * 1 - тайм-аут;
  * 2 - какая-то ошибка.

### mutex\_create ###

**Примеры**
```
new_mutex = mutex_create()
mutex_lock( new_mutex )
mutex_unlock( new_mutex )
mutex_destroy( new_mutex )
```

### mutex\_destroy ###

### mutex\_lock ###

### mutex\_trylock ###

### mutex\_unlock ###

## Математика ##

acos( x ); acosh( x ); asin( x ); asinh( x ); atan( x ); atanh( x ); ceil( x ); cos( x ); cosh( x ); exp( x ); exp2( x ); expm1( x );
abs( x ); floor( x ); mod( x, y ); log( x ); log2( x ); log10( x ); pow( base, exp ); sin( x ); sinh( x ); sqrt( x ); tan( x ); tanh( x );

rand() - получить случайное число в диапазоне от 0 до 32767;
rand\_seed( seed ) - установить позицию (состояние) генератора случайных чисел.

## Обработка данных ##

Примечание: функции обработки данных не работают с контейнерами динамического типа.

### op\_cn ###

Выполнить операцию обработки данных.
Операнды:
  1. контейнер C1;
  1. числовое значение N.

Для каждого элемента контейнера C1 будет выполняться следующее:
```
C1[ i ] = C1[ i ] OP N,
где i - номер элемента; OP - выбранная операция.
```

**Параметры ( opcode, C1, N ) - для всего контейнера С1**

**Параметры ( opcode, C1, N, x, xsize ) - область задана в 1D координатах**

**Параметры ( opcode, C1, N, x, y, xsize, ysize ) - область задана в 2D координатах**

  * opcode - код операции;
  * C1 - контейнер, над которым будет производиться выбранная операция; результат будет помещен в него же;
  * N - числовое значение;
  * x,y,xsize,ysize - регион, в котором будет выполняться операция.

**Примеры**
```
//Прибавить число 32 к каждому элементу контейнера img:
op_cn( OP_ADD, img, 32 )

//Прибавить число 32 к элементам 128...256:
op_cn( OP_ADD, img, 32, 128, 128 ) 

//Прибавить число 32 к элементам в регионе (8,8,32,32):
op_cn( OP_ADD, img, 32, 8, 8, 32, 32 )
```

### op\_cc ###

Выполнить операцию обработки данных.
Операнды:
  1. контейнер C1;
  1. контейнер C2.

Для каждого элемента контейнера C1 будет выполняться следующее:
```
C1[ i ] = C1[ i ] OP C2[ i ],
где i - номер элемента; OP - выбранная операция.
```

**Параметры ( opcode, C1, C2 ) - для всей области контейнера С1**

**Параметры ( opcode, C1, C2, dest\_x, src\_x, xsize ) - область задана в 1D координатах**

**Параметры ( opcode, C1, C2, dest\_x, dest\_y, src\_x, src\_y, xsize, ysize ) - область задана в 2D координатах**

### op\_ccn ###

Выполнить операцию обработки данных.
Операнды:
  1. контейнер C1;
  1. контейнер C2;
  1. числовое значение N.

Для каждого элемента контейнера C1 будет выполняться следующее:
```
C1[ i ] = C1[ i ] OP C2[ i ] OP2 N,
где i - номер элемента; OP - выбранная операция; OP2 - дополнительная операция.
```

**Параметры ( opcode, C1, C2, N ) - для всей области контейнера C1**

**Параметры ( opcode, C1, C2, N, dest\_x, src\_x, xsize ) - область задана в 1D координатах**

**Параметры ( opcode, C1, C2, N, dest\_x, dest\_y, src\_x, src\_y, xsize, ysize ) - область задана в 2D координатах**

### generator ###

Генератор сигнала.

**Параметры ( opcode, pixi, phase, amplitude, delta\_x, delta\_y, x, y, xsize, ysize )**
  * opcode - код операции;
  * pixi - номер контейнера;
  * phase - начальная фаза;
  * amplitude - амплитуда;
  * delta\_x - скорость изменения фазы по горизонтали;
  * delta\_y - скорость изменения фазы по вертикали;
  * x,y,xsize,ysize - регион, в котором будет выполняться операция.

**Примеры**
```
//Сгенерировать синусоиду в контейнер img:
generator( OP_SIN, img, 0, 1, 0.1, 0.1 )

//Сгенерировать синусоиду по более быстрому, но менее точному алгоритму:
generator( OP_SIN8, img, 0, 1, 0.1, 0.1 )

//Сгенерировать синусоиду в элементы 8...128 контейнера img:
generator( OP_SIN, img, 0, 1, 0.1, 0.1, 8, 120 )

//Сгенерировать синусоиду в регион (8,8,32,32) контейнера img:
generator( OP_SIN, img, 0, 1, 0.1, 0.1, 8, 8, 32, 32 )
```

### wavetable\_generator ###

Очень быстрый многоканальный сэмплер (набор из неограниченного количества примитивных генераторов), где сэмпл имеет фиксированный размер (32768 отсчетов) и всегда зациклен (loop).

**Параметры ( dest, dest\_offset, dest\_length, table, amp, amp\_delta, pos, pos\_delta, gen\_offset, gen\_step, gen\_count )**
  * dest - INT16 или FLOAT32 контейнер, в который будет происходить запись;
  * dest\_offset - смещение;
  * dest\_length - длина генерируемого участка;
  * table - контейнер с базовой волной (сэмплом) (поддерживаются такие форматы: 32768 x INT16, 32768 x FLOAT32);
  * amp - INT32 массив амплитуд (fixed point 16.16);
  * amp\_delta - INT32 массив значений delta для амплитуды (fixed point 16.16);
  * pos - INT32 массив с текущими смещениями внутри table (fixed point 16.16);
  * pos\_delta - INT32 массив со скоростями проигрывания (fixed point 16.16);
  * gen\_offset - номер первого генератора;
  * gen\_step - играть каждый gen\_step генератор;
  * gen\_count - общее количество генераторов, которые нужно проиграть.

**Возвращаемое значение**

0 в случае успешного завершения.

### sampler ###

**Параметры ( sample\_info )**

**Примеры**
```
sample_data = new( 256, 1, INT16 ) //создаем 16-битный сэмпл
sample_info = new( SMP_INFO_SIZE, 1, INT32 ) //создаем контейнер для сэмплера
clean( sample_info )
sample_info[ SMP_DEST ] = buffer //Контейнер, в который будем записывать
sample_info[ SMP_DEST_OFF ] = 0 //Смещение в контейнере
sample_info[ SMP_DEST_LEN ] = 256 //Размер области, которую будем заполнять
sample_info[ SMP_SRC ] = sample_data
sample_info[ SMP_SRC_OFF_H ] = 0 //Смещение сэмпла (левая часть числа с фиксированной точкой)
sample_info[ SMP_SRC_OFF_L ] = 0 //Смещение сэмпла (правая часть числа с фиксированной точкой, от 0 до 65535)
sample_info[ SMP_SRC_SIZE ] = 0 //Размер сэмпла (0 - весь сэмпл целиком)
sample_info[ SMP_LOOP ] = 0 //Начало лупа (повторяемого участка сэмпла)
sample_info[ SMP_LOOP_LEN ] = 128 //Длина лупа (или 0, если луп отключен)
sample_info[ SMP_VOL1 ] = 0 //Начальная громкость
sample_info[ SMP_VOL2 ] = 32768 //Конечная громкость (32768 = 1.0)
sample_info[ SMP_DELTA ] = ( 1 << 16 ) //Дельта (скорость проигрывания); fixed point (real_value * 65536)
sample_info[ SMP_FLAGS ] = SMP_FLAG_INTERP4 | SMP_FLAG_PINGPONG //Кубическая сплайновая интерполяция и луп в режиме ping-pong
sampler( sample_info ) //Записываем сэмпл с выбранными параметрами в контейнер buffer
```

### envelope2p ###

Применить огибающую (из двух точек) усиления и DC-смещения к выделенной области контейнера. Без ограничения (защиты от переполнения).

**Параметры ( data\_cont, v1, v2, offset, size, dc\_offset1, dc\_offset2 )**
  * data\_cont - исходный контейнер с данными;
  * v1 - начальное значение амплитуды (0 - отсутствие сигнала; 32768 - исходная амплитуда; 32768\*2 - двукратное усиление);
  * v2 - конечное значение амплитуды (0 - отсутствие сигнала; 32768 - исходная амплитуда; 32768\*2 - двукратное усиление);
  * offset - смещение в контейнере data\_cont; опциональный; по умолчанию - 0;
  * size - размер активной области контейнера; опциональный; по умолчанию - весь контейнер;
  * dc\_offset1 - начальное DC смещение; опциональный; по умолчанию - 0;
  * dc\_offset2 - конечное DC смещение; опциональный; по умолчанию - 0.

### gradient ###

**Параметры ( container, val1, val2, val3, val4, x, y, xsize, ysize, x\_step, y\_step )**

### fft ###

Выполнить быстрое преобразование Фурье.

**Параметры ( inverse, im, re, size )**

### new\_filter ###

Создать новый фильтр, в основе которого следующая функция:
```
output[ n ] = ( a[ 0 ] * input[ n ] + a[ 1 ] * input[ n - 1 ] + ... + a[ a_count - 1 ] * input[ n - a_count - 1 ]
                                    + b[ 0 ] * output[ n - 1 ] + ... + b[ b_count - 1 ] * output[ n - b_count - 1 ] ) >> rshift;
```

**Параметры ( flags\_for\_future\_use )**

**Возвращаемое значение**

Новый контейнер, в котором находятся данные фильтра.

### remove\_filter ###

**Параметры ( filter )**

### reset\_filter ###

**Параметры ( filter )**

### init\_filter ###

**Параметры ( filter, a, b, rshift, flags )**
  * filter;
  * a - контейнер с коэффициентами входного сигнала;
  * b - контейнер с коэффициентами обратной связи; опциональный; может быть -1 (если фильтр нерекурсивный);
  * rshift - битовый сдвиг вправо для операций с фиксированной точкой; опциональный;
  * flags - флаги на будущее; опциональный.

**Возвращаемое значение**

0 в случае успешной инициализации фильтра.

### apply\_filter ###

Применить фильтр.

**Параметры ( filter, output, input, flags, offset, size )**
  * filter;
  * output - контейнер с выходными данными;
  * input - контейнер с входными данными;
  * flags - флаги на будущее; опциональный;
  * offset - смещение внутри контейнеров output и input; опциональный;
  * size - размер обрабатываемого блока; опциональный; по умолчанию - весь контейнер.

**Возвращаемое значение**

0 в случае успешного применения фильтра.

### replace\_values ###

Подстановка значений контейнера. Типы контейнеров dest и values должны быть одинаковыми. Для каждого элемента контейнера dest будет выполняться следующее действие: `dest[ i ] = values[ (unsigned)src[ i ] ]`

**Параметры ( dest, src, values, dest\_offset, src\_offset, size )**
  * dest - куда;
  * src - откуда;
  * values - подставляемые значения;
  * dest\_offset - смещение в контейнере dest; опциональный;
  * src\_offset - смещение в контейнере src; опциональный;
  * size - количество элементов, которые нужно изменить; опциональный.

**Примеры**
```
//Преобразовать 8-битную картинку в формат пикселей текущего экрана:
//src - это, например, контейнер основного экрана;
//img8 - контейнер с 8-битной картинкой (256 цветов);
//palette - контейнер с палитрой из 256 цветов;
replace_values( scr, img8, palette )
```

### copy\_and\_resize ###

Скопировать (и растянуть/сжать, если нужно) указанную область контейнера src в указанную область контейнера dest.

**Параметры ( dest, src, flags, dest\_x, dest\_y, dest\_rect\_xsize, dest\_rect\_ysize, src\_x, src\_y, src\_rect\_xsize, src\_rect\_ysize )**
  * dest - куда;
  * src - откуда;
  * flags - флаги RESIZE\_xxx; опциональный; по умолчанию - RESIZE\_INTERP1;
  * dest\_x, dest\_y, dest\_rect\_xsize, dest\_rect\_ysize, src\_x, src\_y, src\_rect\_xsize, src\_rect\_ysize - опциональные параметры.

## Диалоги ##

### file\_dialog ###

Открыть диалоговое окно выбора файла.

**Параметры ( dialog\_name, mask, id, default\_name )**
  * dialog\_name - название окна;
  * mask - типы файлов (например, "gif/jpg" для отображения .gif и .jpg файлов; или "" для отображения всех файлов);
  * id - имя файла, в который будет сохраняться состояние текущего диалога (например, "myprogram\_jpeg\_files");
  * default\_name - имя файла по умолчанию; опциональный.

**Возвращаемое значение**

Номер контейнера с именем выбранного файла, или -1, если файл не выбран. Контейнер удаляется вручную.

### prefs\_dialog ###

Открыть диалоговое окно с глобальными настройками Pixilang.

## Сеть ##

### open\_url ###

Открыть указанный URL в браузере.

**Параметры ( url\_string )**

## Нативный код ##

### dlopen ###

Открыть динамически подключаемую библиотеку (например, .DLL для Windows, или .SO для Linux).

**Параметры ( lib\_file\_name )**

**Возвращаемое значение**

ID открытой библиотеки, или -1 в случае ошибки.

**Примеры**
```
//Например, мы имеем какую-то C функцию int show_info( int x, int y, void* data )
//в библиотеке mylib.dll.
//Вызовем ее из Pixilang:
dl = dlopen( "mylib.dll" ) //Открываем библиотеку
if dl >= 0 
{
  f = dlsym( dl, "show_info", "iip" ) //Получаем ID функции show_info()
  // "iip" - int int pointer
  if f >= 0
  {
    retval = dlcall( dl, f, 1, 2, "blahblah" ) //вызываем функцию show_info() с параметрами 1, 2, "blahblah"
  }
  dlclose( dl ) //Закрываем библиотеку
}
```

### dlclose ###

Закрыть динамически подключаемую библиотеку.

**Параметры ( lib\_id )**

### dlsym ###

Получить ID символа (функции или переменной) из динамической библиотеки.

**Параметры ( lib\_id, symbol\_name, format, calling\_convention )**
  * lib\_id;
  * symbol\_name - имя функции или переменной;
  * format - формат функции; опциональный; это текстовая строка следующего вида: "R(P)", где R - тип возвращаемого значения (один ascii символ), P - типы параметров (несколько ascii символов, или их полное отсутствие); ниже приведен список ascii символов, из которых эта строка строится:
    * v - void;
    * c - signed int8;
    * C - unsigned int8
    * s - signed int16;
    * S - unsigned int16;
    * i - signed int32;
    * I - unsigned int32;
    * l - signed int64;
    * L - unsigned int64;
    * f - float32;
    * d - double64;
    * p - pointer;
  * calling\_convention - одна из констант CCONV\_xxx; опциональный.

**Возвращаемое значение**

ID символа, или -1 в случае ошибки.

### dlcall ###

Вызвать функцию из динамической библиотеки.

**Параметры ( lib\_id, symbol\_id, optional\_function\_parameters )**

## Системные функции ##

### system ###

Выполнить системную команду.

**Параметры ( command )**

**Примеры**
```
//Удаляем файл в Unix-совместимой ОС:
system( "rm /tmp/data.txt" )
```

### argc ###

Функция возвращает количество аргументов, переданных программе.

### argv ###

Функция возвращает контейнер со строкой, в которой записан аргумент под номером n.

**Параметры ( n )**

**Примеры**
```
if argc() >= 4 
{
  a = argv( 3 )
  remove( a )
}
```

### exit ###

Выйти из Pixilang.

**Параметры ( exit\_code )**

**Примеры**
```
exit( 4 ) //Выйти с кодом 4
```