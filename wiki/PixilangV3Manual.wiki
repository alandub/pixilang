<wiki:toc max_depth="3" />

= What is Pixilang =

Pixilang — cross-platform programming language for graphic/sound applications.

= Basics =

The basis of the Pixilang - are containers and variables.

Container is a two-dimensional array of elements. Each element is the number in a specific format. Each container has one format for all its elements. Each container has its own unique ID number.

Variable can contain signed integer (for example 25) of floating point number (for example 33.44).

*The simplest example of the use of containers and variables*
{{{
x = new( 4 ) //Create a new container with 4 pixels. Store its ID into the variable x.
x[ 2 ] = WHITE //Assign the white color to a pixel with number 2.
remove( x ) //Remove this container
}}}
{{{
str = "Hello" //"Hello" is the container with five characters.
//Such containers with strings are created on the stage of compilation of your program. 
//You don't need to delete them manually.
str[ 0 ] = 'h' //Change first character from 'H' to 'h'.
}}}
{{{
a = 4 //Global variable
fn function()
{
  $k = 2 //Local variable
  function2 = {
    //Body of another function
    $x = 899.334 //Local variable
    //$k is not accessible here
  }
  //$x is not accessible here
}
//$k and $x are not accessible here
}}}

= Paths and file names =

In examples
{{{
//File is located in several directories relative to the current location of the pixi-program:
"folder1/folder2/folder3/prog.pixi"

//File is in the current working directory
//  for Linux/Windows/OSX: in the same folder with Pixilang; 
//  for iOS: documents; 
//  for WinCE: root of local filesystem (/);
"1:/prog.pixi"

//File is in the user's directory (for example /home/alex in Linux):
"2:/prog.pixi"

//File is in the temporary directory:
"3:/prog.pixi"
}}}

= Built-in operators =

{{{
//if, else
if a == b 
  { /*This code is executed if a equals b*/ }
else
  { /*This code is executed otherwise*/ }
if x == 4 && y == 2 
  { /*This code is executed if x equals 4 and y equals 2*/ }

//while
a = 0
while( a < 3 )
{
  //This code is executed while a less than 3
  a + 3
}

//go, goto
m1:
a + 1
goto m1 //Go to the m1 label

//halt, stop
halt //Stop the program here

//include
include "prog2.txt" //Include code from prog2.txt

//fn
fn fff( $x, $y ) //Declare function fff with parameters $x and $y
{
  //Function fff body
  ret //Simple return from the function
  ret( 4 ) //Return with value 4
}
}}}

The following table lists the mathematical operators. Priority 0 - the highest, such operations will be executed in the first place.
|| Priority || Operator || Description || Result || Example || 
|| 0 || % || Modulo (remainder) || Integer || a = b % 4 ||
|| 0 || / || Division || Floating point || a = b / 4 ||
|| 0 || div || Integer division || Integer || a = b div 4 ||
|| 0 || `*` || Multiplication || Depends on the operands || a = b `*` 4 ||
|| 1 || + || Addition || Depends on the operands || a = b + 4 ||
|| 1 || - || Subtraction || Depends on the operands || a = b - 4 ||
|| 2 || >> || Bitwise right shift || Integer || a = b >> 4 ||
|| 2 || << || Bitwise left shift || Integer || a = b << 4 ||
|| 3 || == || Equal to || Integer 1 or 0 || if a == b {} ||
|| 3 || != || Not equal to || Integer 1 or 0 || if a != b {} ||
|| 3 || < || Less than || Integer 1 or 0 || if a < b {} ||
|| 3 || > || Greater than || Integer 1 or 0 || if a > b {} ||
|| 3 || <= || Less than or equal to || Integer 1 or 0 || if a <= b {} ||
|| 3 || >= || Greater than or equal to || Integer 1 or 0 || if a >= b {} ||
|| 4 || | || Bitwise OR || Integer || a = b | 4 ||
|| 4 || ^ || Bitwise XOR || Integer || a = b ^ 4 ||
|| 4 || & || Bitwise AND || Integer || a = b & 4 ||
|| 5 ||  `|``|` || Logical OR || Integer 1 or 0 || if a `|``|` b {} ||
|| 5 || && || Logical AND || Integer 1 or 0 || if a && b {} ||

= Built-in constants =

== Container types ==

 * INT - signed integer (size depends on the version of Pixilang).
 * INT8 - signed integer (8 bit).
 * INT16 - signed integer (16 bit).
 * INT32 - signed integer (32 bit).
 * INT64 - signed integer (64 bit).
 * FLOAT - floating point (size depends on the version of Pixilang).
 * FLOAT32 - floating point (32 bit).
 * FLOAT64 - floating point (64 bit).
 * DYNAMIC - dynamic type.
 * PIXEL - pixel; will be converted to type INTx, where x - number of bits per pixel.

== Sizes ==

 * INT_SIZE - max size (in bytes) of the signed integer.
 * FLOAT_SIZE - max size (in bytes) of the floating point number.
 * COLORBITS - number of bits per pixel.

== File formats ==

 * FORMAT_RAW.
 * FORMAT_JPEG.
 * FORMAT_PNG.
 * FORMAT_GIF.
 * FORMAT_WAVE.

== Colors ==

 * ORANGE.
 * BLACK.
 * WHITE.
 * YELLOW.
 * RED.
 * GREEN.
 * BLUE.

== Alignment ==

 * TOP.
 * BOTTOM.
 * LEFT.
 * RIGHT.

== Effects ==

Effect types for effector() function:
 * EFF_NOISE - noise;
 * EFF_HBLUR - horizontal blur;
 * EFF_VBLUR - vertical blur.

== Audio ==

Flags for set_audio_callback() function:
 * AUDIO_FLAG_INTERP2 - linear interpolation (2 points).

== MIDI ==

Flags for midi_get_device(), midi_open_port() functions:
 * MIDI_PORT_READ;
 * MIDI_PORT_WRITE.

== Events ==

 * EVT - number of container with event, which used by get_event() function.
EVT field numbers:
 * EVT_TYPE - event type;
 * EVT_FLAGS - event flags;
 * EVT_TIME - event time;
 * EVT_X (0 - center of the screen);
 * EVT_Y (0 - center of the screen);
 * EVT_KEY;
 * EVT_SCANCODE;
 * EVT_UNICODE.
Event types (for the EVT_TYPE field):
 * EVT_MOUSEBUTTONDOWN;
 * EVT_MOUSEBUTTONUP;
 * EVT_MOUSEMOVE;
 * EVT_TOUCHBEGIN;
 * EVT_TOUCHEND;
 * EVT_TOUCHMOVE;
 * EVT_BUTTONDOWN;
 * EVT_BUTTONUP;
 * EVT_SCREENRESIZE;
 * EVT_QUIT.
Event flags (for the EVT_FLAGS field):
 * EVT_FLAG_SHIFT;
 * EVT_FLAG_CTRL;
 * EVT_FLAG_ALT;
 * EVT_FLAG_MODE;
 * EVT_FLAG_MODS (mask with all modifiers like Shift, Ctrl, etc.);
 * EVT_FLAG_DOUBLECLICK.
Event key codes (for the EVT_KEY field):
 * KEY_MOUSE_LEFT;
 * KEY_MOUSE_MIDDLE;
 * KEY_MOUSE_RIGHT;
 * KEY_MOUSE_SCROLLUP;
 * KEY_MOUSE_SCROLLDOWN;
 * KEY_F1;
 * KEY_F2;
 * KEY_F3;
 * KEY_F4;
 * KEY_F5;
 * KEY_F6;
 * KEY_F7;
 * KEY_F8;
 * KEY_F9;
 * KEY_F10;
 * KEY_F11;
 * KEY_F12;
 * KEY_UP;
 * KEY_DOWN;
 * KEY_LEFT;
 * KEY_RIGHT;
 * KEY_INSERT;
 * KEY_DELETE;
 * KEY_HOME;
 * KEY_END;
 * KEY_PAGEUP;
 * KEY_PAGEDOWN;
 * KEY_CAPS;
 * KEY_SHIFT;
 * KEY_CTRL;
 * KEY_ALT;
 * KEY_UNKNOWN (system virtual key code = code - KEY_UNKNOWN).
Constants for the set_quit_action() function:
 * QA_NONE;
 * QA_CLOSE_VM.

== Mathematical ==

 * M_E - e.
 * M_LOG2E - log,,2,,e.
 * M_LOG10E - log,,10,,e.
 * M_LN2 - log,,e,,2.
 * M_LN10 - log,,e,,10.
 * M_PI - PI.
 * M_2_SQRTPI - 2 / sqrt( PI ).
 * M_SQRT2 - sqrt( 2 ).
 * M_SQRT1_2 - 1 / sqrt( 2 ).

== Data processing operations ==

For op_cn() function:
 * OP_MIN - {{{retval = min( cont.elements + n )}}};
 * OP_MAX - {{{retval = max( cont.elements + n )}}};
 * OP_MAXMOD - {{{retval = max( | cont.elements + n | )}}}.

For op_cn(), op_cc() function:
 * OP_ADD - addition;
 * OP_SADD - addition with saturation;
 * OP_MUL - multiplication;
 * OP_MUL_RSHIFT15 - {{{( c * n ) >> 15}}};
 * OP_DIV - division;
 * OP_AND - bitwise AND;
 * OP_OR - bitwise OR;
 * OP_XOR - bitwise XOR;
 * OP_LSHIFT - bitwise left shift;
 * OP_RSHIFT - bitwise right shift.

For op_cc() function:
 * OP_COPY - copy.

For op_ccn() function:
 * OP_MUL_DIV - {{{c * c / n}}}.

For generator() function:
 * OP_SIN - sinus;
 * OP_SIN8 - fast, but rough sinus (8bit table);
 * OP_RAND - pseudo random (from -amp to +amp).

== Sampler ==

 * SMP_INFO_SIZE - size of the container with sample info.

Sample info field numbers:
 * SMP_DEST - destination container;
 * SMP_DEST_OFF - destination offset;
 * SMP_DEST_LEN - destination length;
 * SMP_SRC - container with sample;
 * SMP_SRC_OFF_H - sample offset (left part of fixed point value);
 * SMP_SRC_OFF_L - sample offset (right part of fixed point value from 0 to 65535);
 * SMP_SRC_SIZE - sample size (or 0 for whole sample);
 * SMP_LOOP - loop start;
 * SMP_LOOP_LEN - loop length (or 0, if no loop);
 * SMP_VOL1 - start volume (32768 = 1.0);
 * SMP_VOL2 - end volume (32768 = 1.0);
 * SMP_DELTA - delta (playing speed); fixed point {{{(real_value * 65536)}}};
 * SMP_FLAGS - flags.

Sample info flags:
 * SMP_FLAG_INTERP2 - linear interpolation (2 points);
 * SMP_FLAG_INTERP4 - cubic spline interpolation (4 points);
 * SMP_FLAG_PINGPONG - ping-pong loop;
 * SMP_FLAG_REVERSE - reverse direction.

== Constants for POSIX compatibility ==

 * FOPEN_MAX.
 * SEEK_CUR.
 * SEEK_END.
 * SEEK_SET.
 * EOF.
 * STDIN.
 * STDOUT.
 * STDERR.

== Various ==

 * PIXILANG_VERSION - Pixilang version (major*100000 + minor*100).
 * OS_NAME - container with system name.
 * CURRENT_PATH.
 * USER_PATH.
 * TEMP_PATH.

= Built-in global variables =

 * WINDOW_XSIZE - user's window width (in pixels).
 * WINDOW_YSIZE - user's window height (in pixels).
 * FPS - frames per second.
 * PPI - pixels per inch.

= Reserved container properties =

These properties can be created after the load() function:
 * sample_rate;
 * channels;
 * file_format;
 * frames - number of frames;
 * frame - current frame number;
 * fps - frames per second;
 * play - auto-play status (0/1);
 * repeat - repeat count (-1 - infinitely);
 * start_time;
 * start_frame.

= Built-in functions =

== Work with containers (memory allocation) ==

=== new ===

Create new data container.

Note: immediately after its creation, the container may contain some random values. You should clean it up or fill it with useful data.

*Parameters ( xsize, ysize, type )*
 * xsize - width.
 * ysize - height.
 * type - type of the atomic element of the container. Valid values:
   * INT - signed integer (size depends on the version of Pixilang);
   * INT8 - signed integer (8 bit);
   * INT16 - signed integer (16 bit);
   * INT32 - signed integer (32 bit);
   * INT64 - signed integer (64 bit);
   * FLOAT - floating point (size depends on the version of Pixilang);
   * FLOAT32 - floating point (32 bit);
   * FLOAT64 - floating point (64 bit);
   * DYNAMIC - dynamic type;
   * PIXEL - pixel; will be converted to type INTx, where x - number of bits per pixel;

*Return value*

Number of the container, or -1 (error).

*Examples*
{{{
p = new() //Create 1x1 container. Element type = pixel.
p = new( 4 ) //Create 4x1 container. Element type = pixel.
p = new( 4, 4 ) //Create 4x4 container. Element type = pixel.
p = new( 4, 4, INT32 ) //Create 4x4 container. Element type = INT32.
}}}

=== remove ===

Remove a container.

*Parameters ( pixi )*
 * pixi - number of a container.

*Examples*
{{{
p = new() //Create new container
remove( p ) //Remove it
}}}

=== resize ===

Resize a container.

*Parameters ( pixi, xsize, ysize, type )*
 * pixi - number of a container.
 * xsize - new width (or -1 if width not changed).
 * ysize - height (or -1 if width not changed).
 * type - type of the atomic element of the container. Valid values:
   * INT8 - signed integer (8 bit);
   * INT16 - signed integer (16 bit);
   * INT32 - signed integer (32 bit);
   * INT64 - signed integer (64 bit);
   * FLOAT32 - floating point (32 bit);
   * FLOAT64 - floating point (64 bit);
   * DYNAMIC - dynamic type;
   * PIXEL - pixel; will be converted to type INTx, where x - number of bits per pixel;

*Return value*

0 - successful; 1 - error.

*Examples*
{{{
p = new( 4, 4 ) //Create new container
resize( p, 32, 32 ) //Resize it from 4x4 to 32x1
resize( p, -1, 64 ) //Resize it from 32x32 to 32x64
remove( p ) //Remove
}}}

=== convert_type ===

Convert the type of a container.

*Parameters ( pixi, new_type )*

=== clean ===

Clean a container (fill with zeroes or with selected values).

*Parameters ( dest_cont, v, offset, count )*
 * dest_cont - container number;
 * v - value (optional; default - 0);
 * offset - offset in dest_cont (optional; default - 0);
 * count - number of elements to fill (optional; default - whole container).

*Examples*
{{{
p = new() //Create new container
clean( p ) //Clean with zero
clean( p, 3 )
clean( p, 3, 0, 24 ) //Fill 24 elements with value 3
remove( p ) //Remove
}}}

=== clone ===

Make a duplicate of the container.

*Parameters ( pixi )*
 * pixi - number of a container.

*Return value*

Number of the new container, or -1 (error).

=== copy ===

Copy container elements from src to dest.

*Parameters ( dest, src, dest_offset, src_offset, count, dest_step, src_step )*
 * dest - destination container;
 * src - source container;
 * dest_offset - offset in destination (first element to copy);
 * src_offset - offset in source (first element to copy);
 * count - number of elements to copy;
 * dest_step - destination writing step (default - 1);
 * src_step - source reading step (default - 1).

*Examples*
{{{
//Copy all elements from img1 to img2:
copy( img2, img1 )
//Copy elements 8...200 from img1 to img2:
copy( img2, img1, 8, 8, 200 )
//Copy elements 8...400 from img1 to img2 with step 2:
copy( img2, img1, 8, 8, 200, 2, 2 )
}}}

*Return value*

Number of copied elements.

=== get_size ===

Get size of a container (number of elements).

*Parameters ( pixi )*
 * pixi - number of a container.

*Examples*
{{{
p = new( 8, 8 ) //Create a new container 8x8
size = get_size( p ) //Save its size to the "size" variable
remove( p )
}}}

=== get_xsize ===

Get width of a container.

*Parameters ( pixi )*
 * pixi - number of a container.

*Examples*
{{{
p = new( 8, 8 ) //Create a new container 8x8
xsize = get_xsize( p ) //Save its width to the "xsize" variable
remove( p )
}}}

=== get_ysize ===

Get height of a container.

*Parameters ( pixi )*
 * pixi - number of a container.

*Examples*
{{{
p = new( 8, 8 ) //Create a new container 8x8
ysize = get_xsize( p ) //Save its height to the "ysize" variable
remove( p )
}}}

=== get_esize ===

Get the size of the element of a container (in bytes).

*Parameters ( pixi )*
 * pixi - number of a container.

*Examples*
{{{
p = new( 8, 8, INT32 ) //Create a new container 8x8; element type = INT32
esize = get_esize( p ) //Save its element's size to the "esize" variable
//Now esize = 4.
remove( p )
}}}

=== get_type ===

Get the type of the element of a container

*Parameters ( pixi )*
 * pixi - number of a container.

*Examples*
{{{
p = new( 8, 8, FLOAT32 ) //Create a new container 8x8; element type = FLOAT32
type = get_type( p ) //Save its element's type to the "type" variable
//Now type = FLOAT32.
remove( p )
}}}

=== get_prop ===

Get property value of the container. Each container can have unlimited number of properties.

*Parameters ( pixi, prop_name, def_value )*
 * pixi - number of a container;
 * prop_name - property name;
 * def_vaule - default value, if the property is not exists (optional).

*Return value*

Value of selected property.

=== set_prop ===

Set property value of the container.

*Parameters ( pixi, prop_name, value )*
 * pixi - number of a container;
 * prop_name - property name;
 * value.

*Examples*
{{{
p = new( 8, 8, INT32 ) //Create a new container
set_prop( p, "speed", 777 ) //Add "speed" property to this container
v = get_prop( p, "speed" ) //Read the value of "speed" property
}}}

=== remove_props ===

Remove all properties of the selected container.

*Parameters ( pixi )*

== Strings ==

=== num_to_str ===

Aliases: num2str.

Convert number to string.

*Parameters ( str, num )*
 * str - container for the string;
 * num - numeric value.

*Examples*
{{{
v = 45.64
s = ""
num_to_str( s, v )
fputs( s ) fputs( "\n" )
}}}

=== str_to_num ===

Aliases: str2num.

Convert string to number.

*Parameters ( str )*
 * str - container with the string.

*Return value*

Numeric value.

*Examples*
{{{
a = str_to_num( "-55.44" )
b = a + 4
}}}

== File formats ==

=== load ===

*Examples*
{{{
c = load( "smile.jpg" )
}}}

=== save ===

*Parameters ( pixi, filename, format, quality )*
 * pixi;
 * filename;
 * format;
 * quality (0 - worst; 100 - best).

*Examples*
{{{
c = load( "smile.jpg" )
save( c, "smile.png", FORMAT_PNG )
save( c, "smile2.jpg", FORMAT_JPEG ) //Quality = 85 (default)
save( c, "smile3.jpg", FORMAT_JPEG, 100 ) //Quality = 100
}}}

== Graphics ==

=== frame ===

Draw current screen on display and delay for selected number of milliseconds.

*Parameters ( delay, x, y, xsize, ysize )*
 * delay - pause length in milliseconds;
 * x, y, xsize, ysize - region of the screen; optional parameters.

=== set_screen ===

Set current screen.

*Parameters ( pixi )*
 * pixi - container with image, which will be the screen.

=== get_screen ===

Get current screen.

*Return value*

Container's number.

=== set_zbuf ===

*Parameters ( zbuf_container )*

Set container with Z-buffer. Must be INT32.

=== get_zbuf ===

=== get_color ===

Get color by r,g,b (red,green,blue).

*Parameters ( red, green, blue )*
 * red - red intensity (from 0 до 255);
 * green - green intensity (from 0 до 255);
 * blue - blue intensity (from 0 до 255).

*Return value*

Color.

=== get_red ===

Get red component intensity in a selected color.

*Parameters ( color )*

*Return value*

Red component intensity. From 0 to 255.

=== get_green ===

Get green component intensity in a selected color.

*Parameters ( color )*

*Return value*

Green component intensity. From 0 to 255.

=== get_blue ===

Get blue component intensity in a selected color.

*Parameters ( color )*

*Return value*

Blue component intensity. From 0 to 255.

=== get_blend ===

Get an intermediate color value between two selected colors.

*Parameters ( c1, c2, v )*
 * c1 - first color;
 * с2 - second color;
 * v - position between c1 and c2; 0 - closer to c1; 255 - closer to c2.

*Return value*

Intermediate color.

=== transp ===

Set transparency.

*Parameters ( t )*
 * t - transparency from 0 to 255.

=== get_transp ===

=== clear ===

Clear current screen.

*Parameters ( color )*

=== dot ===

Draw a dot.

*Parameters ( x, y, color )*

=== dot3d ===

Draw a dot in 3D.

*Parameters ( x, y, z, color )*

=== get_dot ===

Get a dot's color.

*Parameters ( x, y )*

*Return value*

Color.

=== get_dot3d ===

Get a dot's color in 3D.

*Parameters ( x, y, z )*

*Return value*

Color.

=== line ===

Draw a line.

*Parameters ( x1, y1, x2, y2, color )*

=== line3d ===

Draw a line in 3D.

*Parameters ( x1, y1, z1, x2, y2, z2, color )*

=== box ===

Draw a rectangle.

*Parameters ( x, y, xsize, ysize, color )*

=== fbox ===

Draw a filled rectangle.

*Parameters ( x, y, xsize, ysize, color )*

=== pixi === 

Display the container with the picture. 

* Parameters ( pixi_cont, x, y, color, xscale, yscale, src_x, src_y, src_xsize, src_ysize ) * 
 * pixi_cont - container number (source); 
 * x; 
 * y;
 * color - color of the filter; optional; default value is WHITE;
 * xscale - scaling factor (x axis); optional; default value is 1;
 * yscale - scaling factor (y axis); optional; default value is 1;
 * src_x - x offset in pixi_cont; default - 0;
 * src_y - y offset in pixi_cont; default - 0;
 * src_xsize - width of drawable pixi_cont region; default - width of pixi_cont;
 * src_ysize - height of drawable pixi_cont region; default - height of pixi_cont.

*Examples*
{{{
pixi( image )
pixi( image, 10, 20 )
pixi( image, 30, 40, GREEN )
pixi( image, 90, 20, GREEN, 0.5, 0.5 )
}}}

=== set_key_color === 

Set / reset the color of transparency in the container. 

* Parameters ( pixi, color ) * 
 * pixi - container number; 
 * color - color to be transparent; ignore this parameter if you want to disable transparent color for this container.

=== get_key_color ===

=== set_alpha === 

Attach a container with alpha channel to another container. Alpha channel should be of type INT8. 

* Parameters ( pixi, alpha ) * 
 * pixi - container number; 
 * alpha - container with alpha channel; ignore this parameter if you want to disable alpha-channel for the pixi container.

=== get_alpha ===

=== print ===

Show text on the screen.

*Parameters ( text, x, y, color, align )* 
 * text - container with text;
 * x, y - point of the alignment;
 * color;
 * align - alignment.

*Examples*
{{{
print( "Hello Pixi!", 0, 0 ) //color = WHITE; centered;
print( "line1\nline2", 50, 50, RED ) //centered;
print( "line1\nline2", -50, 50, RED, TOP | LEFT ) //alignment = top left;
}}}

=== get_text_xsize ===

*Parameters ( text, align )*

*Return value*

Text width in pixels.

=== get_text_ysize ===

*Parameters ( text, align )*

*Return value*

Text height in pixels.

=== set_font ===

*Parameters ( first_char_utf32, font_image, xchars, ychars )*

=== get_font ===

*Parameters ( char_utf32 )*

*Return value*

Container ID with font for selected character.

=== effector ===

Apply an effect to selected screen area. Coordinates of this function can't be changed by t_xxx transformation functions.

*Parameters ( type, power, color, x, y, xsize, ysize, x_step, y_step )*

== Animation ==

=== pack_frame ===

Pack current frame (from container data to hidden storage with frames). Frame number must be stored in the "frame" container property.

*Parameters ( pixi )*

=== unpack_frame ===

Unpack current frame (from hidden storage with frames to container data). Frame number must be stored in the "frame" container property.

*Parameters ( pixi )*

=== create_anim ===

Create the hidden storage with frames (animation) in the selected container.

*Parameters ( pixi )*

=== remove_anim ===

Remove the hidden storage with frames (animation) from the selected container.

*Parameters ( pixi )*

=== clone_frame ===

Clone current frame. Frame number must be stored in the "frame" container property.

*Parameters ( pixi )*

=== remove_frame ===

Remove current frame. Frame number must be stored in the "frame" container property.

*Parameters ( pixi )*

=== play ===

Enable auto-play mode. Frame will be changed automatically during the pixi() function call.

*Parameters ( pixi )*

=== stop ===

Disable auto-play mode.

*Parameters ( pixi )*

== Transformation ==

Coordinate system transformation.

=== t_reset ===

Reset transformation.

=== t_rotate ===

*Parameters ( angle, x, y, z )*

=== t_translate ===

*Parameters ( x, y, z )*

=== t_scale ===

*Parameters ( x, y, z )*

=== t_get_matrix ===

Get transformation matrix (4x4 FLOAT).

*Parameters ( matrix_container )*

=== t_set_matrix ===

Set transformation matrix (4x4 FLOAT).

*Parameters ( matrix_container )*

=== t_mul_matrix ===

Multiply transformation matrix (4x4 FLOAT). 
{{{Current matrix = current matrix * matrix_container}}}

*Parameters ( matrix_container )*

=== t_point ===

Transform point (container with 3 elements of type FLOAT).

*Parameters ( point_coordinates )*

== Audio ==

=== set_audio_callback ===

*Parameters ( callback, userdata, freq, format, channels, flags )*

*Examples*
{{{
fn audio_callback( $stream, $userdata, $channels, $frames, $time )
{
  generator( OP_SIN, $channels[ 0 ], 0, 32767 / 2, 0.1, 0 ) //Left channel
  generator( OP_SIN, $channels[ 1 ], 0, 32767 / 2, 0.1, 0 ) //Right channel
  ret(1)
}
//Start audio:
set_audio_callback( audio_callback, 0, 22050, INT16, 2, AUDIO_FLAG_INTERP2 )
}}}
{{{
//Stop audio:
set_audio_callback( -1 )
}}}

=== enable_audio_input ===

*Parameters ( disable_enable )*

=== get_note_freq ===

*Parameters ( note, finetune )*
 * note - note number; 0 = C-0; 1 = C#0; 2 = D-0 ...
 * finetune - from -64 (previous note) to 64 (next note).

*Return value*

Note frequency in Hz.

== MIDI ==

=== midi_open_client ===

*Parameters ( client_name )*

*Return value*

Client ID.

=== midi_close_client ===

*Parameters ( client_id )*

=== midi_get_device ===

*Parameters ( client_id, device_num, flags )*

*Return value*

Selected device name, or -1 if not exists.

=== midi_open_port ===

*Parameters ( client_id, port_name, device_name, flags )*

*Return value*

Port ID.

=== midi_reopen_port ===

*Parameters ( client_id, port_id )*

=== midi_close_port ===

*Parameters ( client_id, port_id )*

=== midi_get_event ===

*Parameters ( client_id, port_id, data_cont )*

*Return value*

Size of current MIDI event (in bytes).

=== midi_get_event_time ===

*Parameters ( client_id, port_id )*

*Return value*

Time of current event (in system ticks).

=== midi_next_event ===

Go to the next event.

*Parameters ( client_id, port_id )*

=== midi_send_event ===

*Parameters ( client_id, port_id, data_cont, data_size, t )*

== Time ==

=== start_timer ===

Start selected timer.

*Parameters ( timer_num )*

=== get_timer ===

Get value (in milliseconds) of selected timer. 

*Parameters ( timer_num )*

*Return value*

32bit value (in milliseconds) of selected timer.

=== get_year ===

=== get_month ===

=== get_day ===

=== get_hours ===

=== get_minutes ===

=== get_seconds ===

=== get_ticks ===

Get current system tick counter (32bit).

=== get_tps ===

Get number of system ticks per second.

=== sleep ===

*Parameters ( delay )*
 * delay - delay in milliseconds.

== Events ==

=== get_event ===

Get a new event from the system.

*Return value*

0 - no events. 1 - event is received and placed into a container EVT.

=== set_quit_action ===

Set the program's behavior when receiving event EVT_QUIT.

*Parameters ( action )*
 * action - action number.

Possible values for the action parameter:
 * QA_NONE - do nothing;
 * QA_CLOSE_VM (default) - close the current virtual machine, but don't quit from Pixilang.

== Threads ==

=== thread_create ===

*Parameters ( thread_function, user_data )*

*Return value*

Thread number or -1 if error occurred.

=== thread_destroy ===

*Parameters ( thread_num, timeout_ms )*

*Return value*

0 if the thread closed successfully.

=== mutex_create ===

*Examples*
{{{
new_mutex = mutex_create()
mutex_lock( new_mutex )
mutex_unlock( new_mutex )
mutex_destroy( new_mutex )
}}}

=== mutex_destroy ===

=== mutex_lock ===

=== mutex_trylock ===

=== mutex_unlock ===

== Mathematical ==

=== acos ===
=== acosh ===
=== asin ===
=== asinh ===
=== atan ===
=== atanh ===
=== ceil ===
=== cos ===
=== cosh ===
=== exp ===
=== exp2 ===
=== expm1 ===
=== abs ===
=== floor ===
=== mod ===
=== log ===
=== log2 ===
=== log10 ===
=== pow ===
=== sin ===
=== sinh ===
=== sqrt ===
=== tan ===
=== tanh ===
=== rand ===
=== rand_seed ===

== Data processing ==

Note: data processing functions can't work with dynamic containers.

=== op_cn ===

Execute data processing operation.
Operands: 1) container (c); 2) numerical value (n).

*Parameters ( opcode, pixi, num, x, y, xsize, ysize )*
 * opcode - operation;
 * pixi - container (c);
 * num - numerical value (n);
 * x,y,xsize,ysize - region.

*Examples*
{{{
//Add 32 to the whole container img:
op_cn( OP_ADD, img, 32 )

//Add 32 to 128..256th elements of the container img:
op_cn( OP_ADD, img, 32, 128, 128 ) 

//Add 32 to two-dimensional region (8,8,32,32) of elements:
op_cn( OP_ADD, img, 32, 8, 8, 32, 32 )
}}}

=== op_cc ===

Execute data processing operation.
Operands: 1) container (c); 2) container (c). 

Operation expression: {{{for each element of pixi1: pixi1[ i ] = pixi1[ i ] OP pixi2[ i ]}}}

*Parameters ( opcode, pixi1, pixi2 ) - for whole container pixi1*
 * pixi1 - destination;
 * pixi2 - source.

*Parameters ( opcode, pixi1, pixi2, dest_x, src_x, xsize ) - for 1D region*

*Parameters ( opcode, pixi1, pixi2, dest_x, dest_y, src_x, src_y, xsize, ysize ) - for 2D region*

=== op_ccn ===

Execute data processing operation.
Operands: 1) container (c); 2) container (c) 3) numerical value (n). 

Operation expression: {{{for each element of pixi1: pixi1[ i ] = pixi1[ i ] OP pixi2[ i ] / num}}}

*Parameters ( opcode, pixi1, pixi2, num ) - for whole container pixi1*
 * pixi1 - destination;
 * pixi2 - source;
 * num - numerical value (operation parameter).

*Parameters ( opcode, pixi1, pixi2, num, dest_x, src_x, xsize ) - for 1D region*

*Parameters ( opcode, pixi1, pixi2, dest_x, dest_y, num, src_x, src_y, xsize, ysize ) - for 2D region*

=== generator ===

Generate a signal.

*Parameters ( opcode, pixi, phase, amplitude, delta_x, delta_y, x, y, xsize, ysize )*
 * opcode - operation;
 * pixi - container;
 * phase;
 * amplitude;
 * delta_x;
 * delta_y;
 * x,y,xsize,ysize - region.

*Examples*
{{{
//Generate a sine wave to the whole container img:
generator( OP_SIN, img, 0, 1, 0.1, 0.1 )

//Generate a rough sine wave to the whole container img:
generator( OP_SIN8, img, 0, 1, 0.1, 0.1 )

//Generate a sine wave to 8...128 elements of the container img:
generator( OP_SIN, img, 0, 1, 0.1, 0.1, 8, 128 )

//Generate a sine wave to region (8,8,32,32) of the container img:
generator( OP_SIN, img, 0, 1, 0.1, 0.1, 8, 8, 32, 32 )
}}}

=== sampler ===

*Parameters ( sample_info )*

*Examples*
{{{
sample_data = new( 256, 1, INT16 ) //16bit sample
sample_info = new( SMP_INFO_SIZE, 1, INT32 )
clean( sample_info )
sample_info[ SMP_DEST ] = buffer //Destination container
sample_info[ SMP_DEST_OFF ] = 0 //Destination offset
sample_info[ SMP_DEST_LEN ] = 256 //Destination length
sample_info[ SMP_SRC ] = sample_data
sample_info[ SMP_SRC_OFF_H ] = 0 //Sample offset (left part of fixed point value)
sample_info[ SMP_SRC_OFF_L ] = 0 //Sample offset (right part of fixed point value from 0 to 65535)
sample_info[ SMP_LOOP ] = 0 //Loop start
sample_info[ SMP_LOOP_LEN ] = 128 //Loop length (or 0, if no loop)
sample_info[ SMP_VOL1 ] = 0 //Start volume
sample_info[ SMP_VOL2 ] = 32768 //End volume (32768 = 1.0)
sample_info[ SMP_DELTA ] = ( 1 << 16 ) //Delta; fixed point (real_value * 65536)
sample_info[ SMP_FLAGS ] = SMP_FLAG_INTERP4 | SMP_FLAG_PINGPONG //Cubic spline interpolation and ping-pong loop
sampler( sample_info ) //Go!
}}}

=== envelope2p ===

Apply gain and DC-offset two-points envelope to selected container area. Without clipping.

*Parameters ( data_cont, v1, v2, offset, size, dc_offset1, dc_offset2 )*
 * data_cont - container with data (audio waveform, for example);
 * v1 - initial gain (0 - no signal; 32768 - original unchanged amplitude);
 * v2 - final gain (0 - no signal; 32768 - original unchanged amplitude);
 * offset - offset in the data_cont (optional; default - 0);
 * size - size of area for envelope (optional; default - whole container);
 * dc_offset1 - initial DC offset (optional; default - 0);
 * dc_offset1 - final DC offset (optional; default - 0).

=== fft ===

Perform a fast fourier transform.

*Parameters ( inverse, im, re, size )*

=== replace_values ===

For each element of dest container: {{{dest[ i ] = values[ (unsigned)src[ i ] ]}}}. 
The dest container must have the same type as the values.

*Parameters ( dest, src, values )*
 * dest - destination;
 * src - source;
 * values - substitution values.

*Examples*
{{{
//Convert 8-bit image with palette to the screen pixel format:
replace_values( scr, img8, palette )
}}}

== Dialogs ==

=== file_dialog ===

Open file dialog.

*Parameters ( dialog_name, mask, id, default_name )*
 * dialog_name;
 * mask - file type mask (examples: "gif/jpg" for .gif and .jpg files; "" for all files);
 * id - name of the file for saving the current dialog state;
 * default_name - default file name (optional).

*Return value*

Container number with selected file name. Or -1 if file not selected. Container must be deleted manually.

== System functions (compatibility with POSIX) ==

=== fopen ===

The fopen() function shall open the file whose pathname is the string pointed to by _filename_, and associates a stream with it.

*Parameters ( filename, mode )*
 * filename;
 * mode:
   * r or rb - open file for reading;
   * w or wb - truncate to zero length or create file for writing;
   * a or ab - append; open or create file for writing at end-of-file;
   * r+ or rb+ or r+b - open file for update (reading and writing);
   * w+ or wb+ or w+b - truncate to zero length or create file for update;
   * a+ or ab+ or a+b - append; open or create file for update, writing at end-of-file.

*Return value*

Upon successful completion, fopen() shall return ID of the object controlling the stream. Otherwise, 0 shall be returned.

*Examples*
{{{
f = fopen( "/tmp/data.txt", "rb" ) //Open file data.txt for reading
fclose( f ) //...and close it.
}}}

=== fclose ===

The fclose() function shall cause the stream to be flushed and the associated file to be closed.

*Parameters ( stream )*

*Return value*

Upon successful completion, fclose() shall return 0.

*Examples*
{{{
f = fopen( "/tmp/data.txt", "rb" ) //Open file data.txt for reading.
c = fgetc( f ) //Get a byte from this file.
fclose( f ) //Close the stream.
}}}

=== fputc ===

Put a byte on a stream.

*Parameters ( c, stream )*

*Examples*
{{{
f = fopen( "/tmp/data.txt", "wb" ) //Open file data.txt for writing.
fputc( 0x12, f ) //Put a byte 0x12 to this file.
fclose( f ) //Close the stream.
}}}

=== fputs ===

Put a string on a stream.

*Parameters ( s, stream )*

*Examples*
{{{
f = fopen( "/tmp/data.txt", "wb" ) //Open file data.txt for writing.
str = "Hello!"
fputc( str, f ) //Put a string "Hello!" to this file.
fclose( f ) //Close the stream.
}}}

=== fwrite ===

The fwrite() function shall write, from the container _data_, up to _size_ bytes, to the stream pointed to by _stream_.

*Parameters ( data, size, stream )*

*Return value*

The fwrite() function shall return the number of bytes successfully written, which may be less than _size_ if a write error is encountered.

*Examples*
{{{
f = fopen( "/tmp/data.txt", "wb" ) //Open file data.txt for writing.
str = "Hello!"
fwrite( str, 2, f ) //Put first two bytes from the string "Hello!" to this file.
fclose( f ) //Close the stream.
}}}

=== fgetc ===

Get a byte from a stream.

*Parameters ( stream )*

*Return value*

Upon successful completion, fgetc() shall return the next byte from the input stream pointed to by _stream_.

=== fgets ===

Get a string from a stream.

*Parameters ( s, n, stream )*

*Examples*
{{{
string = new( 256, 1, INT8 )
f = fopen( "/tmp/data.txt", "rb" ) //Open file data.txt for reading.
fgets( string, 256, f ) //Get a string from this file.
fclose( f ) //Close the stream.
}}}

=== fread ===

The fread() function shall read into the container pointed to by _data_ up to _size_ bytes, from the stream pointed to by _stream_.

*Parameters ( data, size, stream )*

*Return value*

Upon successful completion, fread() shall return the number of bytes successfully read which is less than _size_ only if a read error or end-of-file is encountered.

=== feof ===

Test end-of-file indicator on a stream.

*Parameters ( stream )*

*Return value*

The feof() function shall return non-zero if and only if the end-of-file indicator is set for _stream_.

=== fflush ===

Flush a stream.

*Parameters ( stream )*

=== fseek ===

Reposition a file-position indicator in a stream.

*Parameters ( stream, offset, origin )*
 * stream;
 * offset;
 * origin:
   * SEEK_SET - beginning of file;
   * SEEK_CUR - current position of the file pointer;
   * SEEK_END - end of file.

=== ftell ===

Return a file offset in a stream.

*Parameters ( stream )*

*Return value*

Upon successful completion, ftell() shall return the current value of the file-position indicator for the stream measured in bytes from the beginning of the file.

*Examples*
{{{
//One of the ways to get the file size:
f = fopen( "/tmp/data.txt", "rb" )
fseek( f, 0, SEEK_END )
size_of_file = ftell( f )
fclose( f )
}}}

=== remove_file ===

*Parameters ( filename )*

=== rename_file ===

*Parameters ( old_filename, new_filename )*

=== copy_file ===

*Parameters ( source_filename, destination_filename )*

=== strcat ===

Appends a copy of the source string to the destination string. Both strings can be with terminating null character or without it (if the size of the container = number of characters in the string). Size of the source string can be changed after this function executes.

*Parameters ( destination, source )*

=== strcmp ===

Compares the string str1 to the string str2. Both strings can be with terminating null character or without it (if the size of the container = number of characters in the string).

*Parameters ( str1, str2 )*

*Return value*

A zero value indicates that both strings are equal. 
A value greater than zero indicates that the first character that does not match has a greater value in str1 than in str2; And a value less than zero indicates the opposite.

=== strlen ===

Returns the length of string str. String can be with terminating null character or without it (if the size of the container = number of characters in the string).

*Parameters ( str )*

*Return value*

Length of string str.

=== strstr ===

Returns the offset of the first occurrence of str2 in str1, or a -1 if str2 is not part of str1.

*Parameters ( str1, str2 )*

*Return value*

Offset of the first occurrence of str2 in str1, or a -1 if str2 is not part of str1.

=== sprintf ===

Writes into the container str a string consisting on a sequence of data formatted as the format argument specifies.

*Parameters ( str, format, ... )*

*Return value*

On success, the total number of characters written is returned. On failure, a negative number is returned.

=== system ===

Issue a OS command.

*Parameters ( command )*

*Return value*

system() shall return the termination status of the command.

*Examples*
{{{
//Remove some file:
system( "rm /tmp/data.txt" )
}}}

=== argc ===

Returns the number of arguments.

=== argv ===

Returns the container with selected argument.

*Parameters ( n )*

*Examples*
{{{
if argc >= 4 
{
  a = argv( 3 )
  remove( a )
}
}}}

=== exit ===

Quit from Pixilang.

*Examples*
{{{
exit( 4 ) //Exit with code 4
}}}