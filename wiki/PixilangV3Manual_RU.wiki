<wiki:toc max_depth="3" />

= Что такое Pixilang =

Pixilang — кросс-платформенный язык программирования для графических и звуковых приложений. Примеры: игры, презентации, открытки, синтезаторы, демки, небольшие утилиты.

Основные приемущества:
 * прост в освоении;
 * легко устанавливается;
 * программа на Pixilang пишется один раз, после чего без проблем запускается в любой операционной системе;
 * исходный код Pixilang полностью открыт.

= Основы =

В основе Pixilang - контейнеры (или pixi-контейнеры, как их иногда называют) и переменные. 

Что такое контейнер? Если в двух словах, то это двухмерный массив, таблица из X колонок и Y строк. Каждая ячейка этой таблицы - число определенного формата. Формат задан один на весь контейнер. Например, ячейки могут хранить цвета пикселей, тогда контейнер превращается в картинку. Контейнер с таким же успехом может быть строкой текста, куском звука и т.д. Если вы знакомы с другими языками программирования, то считайте контейнер массивом, состоящим из (X*Y) ячеек. Каждый контейнер после создания имеет свой порядковый номер.

Переменная - имя ячейки памяти, в которой хранится одно знаковое целое число (например, 25) или число с плавающей запятой (например, 33.44). Локальные переменные (с символом $ перед именем) доступны только в рамках одной функции, в которой эти переменные определены. Глобальные переменные (без символа $) доступны в любом месте программы.

Простейшие примеры применения контейнеров и переменных:
{{{
x = new( 4 ) //Создаем контейнер из 4х пикселей. Сохраняем номер контейнера в переменной x.
x[ 2 ] = WHITE //Присваиваем пикселю номер 2 белый цвет.
remove( x ) //Удаляем контейнер
}}}
{{{
str = "Hello" //"Hello" - это контейнер, состоящий из пяти букв.
//Подобные контейнеры-строки создаются автоматически на этапе компиляции программы.
//Удалять их вручную так, как это сделано в предыдущем примере, не надо.
//Контейнеру со строкой "Hello" автоматически присвоится порядковый номер.
//Например, это будет номер 4.
//Тогда код str = "Hello" будет равноценен коду str = 4.
str[ 0 ] = 'h' //Меняем самую первую букву в строке. Было - 'H'. Станет - 'h'.
}}}
{{{
a = 4 //Глобальная переменная
fn function()
{
  $k = 2 //Локальная переменная
  function2 = {
    //Определяем еще одну функцию
    $x = 899.334 //Локальная переменная
    //В этом месте $k недоступна, т.к. находится в другой функции
  }
  //В этом месте $x недоступна
}
//В этом месте $k и $x недоступны
}}}

= Встроенные операторы =

Рассмотрим операторы на конкретных примерах.

{{{
//Условные операторы if, else
if a == b 
  { /*Код в этом месте выполняется, если a равно b*/ }
else
  { /*Код в этом месте выполняется в противном случае (a не равно b)*/ }
if x == 4 && y == 2 
  { /*Код в этом месте выполняется, если x равно 4 и y равно 2*/ }

//Оператор цикла: while
a = 0
while( a < 3 )
{
  //Код в этом месте выполняется, если a меньше 3
  a + 3
}

//Операторы перехода: go, goto
m1:
a + 1
goto m1 //Переход на метку m1

//Операторы остановки: halt, stop
halt //В этом месте программа останавливается

//Оператор подключения: include
include "prog2.txt" //В этом месте подключаем код из файла prog2.txt

//Оператор определения функции: fn
fn fff( $x, $y ) //Определяем функцию fff с параметрами $x и $y
{
  //Код функции fff
  ret //Простой выход из функции
  ret( 4 ) //Выход из функции с возвращением значения 4
}
}}}

Ниже приведена таблица математических операторов. Приоритет 0 - наивысший, такие операции будут выполняться в первую очередь.
|| Приоритет || Оператор || Описание || Результат || Пример || 
|| 0 || % || Деление по модулю || Целое число || a = b % 4 ||
|| 0 || / || Деление || Число с плавающей запятой || a = b / 4 ||
|| 0 || div || Целочисленное деление || Целое число || a = b div 4 ||
|| 0 || `*` || Умножение || Зависит от операндов || a = b `*` 4 ||
|| 1 || + || Сложение || Зависит от операндов || a = b + 4 ||
|| 1 || - || Вычитание || Зависит от операндов || a = b - 4 ||
|| 2 || >> || Битовый сдвиг вправо || Целое число || a = b >> 4 ||
|| 2 || << || Битовый сдвиг влево || Целое число || a = b << 4 ||
|| 3 || == || Равно || Целое число 1 или 0 || if a == b {} ||
|| 3 || != || Не равно || Целое число 1 или 0 || if a != b {} ||
|| 3 || < || Меньше || Целое число 1 или 0 || if a < b {} ||
|| 3 || > || Больше || Целое число 1 или 0 || if a > b {} ||
|| 3 || <= || Меньше или равно || Целое число 1 или 0 || if a <= b {} ||
|| 3 || >= || Больше или равно || Целое число 1 или 0 || if a >= b {} ||
|| 4 || | || Побитовая операция ИЛИ (OR) || Целое число || a = b | 4 ||
|| 4 || ^ || Побитовая операция исключающего ИЛИ (XOR) || Целое число || a = b ^ 4 ||
|| 4 || & || Побитовая операция И (AND) || Целое число || a = b & 4 ||
|| 5 ||  `|``|` || Логическая операция ИЛИ (OR) || Целое число 1 или 0 || if a `|``|` b {} ||
|| 5 || && || Логическая операция И (AND) || Целое число 1 или 0 || if a && b {} ||

= Встроенные константы =

== Цвета ==

 * ORANGE - ораньжевый.
 * BLACK - черный.
 * WHITE - белый.
 * YELLOW - желтый.
 * RED - красный.
 * GREEN - зеленый.
 * BLUE - синий.

== Выравнивание ==

Эти константы используются, например, при выводе текста. Их можно комбинировать при помощи побитовой операции ИЛИ (|). 
Отсутствие TOP и BOTTOM обозначает вертикальное выравнивание по центру. 
Отсутствие LEFT и RIGHT обозначает горизонтальное выравнивание по центру. 

 * TOP - по верхнему краю.
 * BOTTOM - по нижнему краю.
 * LEFT - по левому краю.
 * RIGHT - по правому краю.

== Типы контейнеров ==

 * INT - знаковое целое (размер зависит от версии Pixilang).
 * INT8 - знаковое целое (8 бит).
 * INT16 - знаковое целое (16 бит).
 * INT32 - знаковое целое (32 бита).
 * INT64 - знаковое целое (64 бита).
 * FLOAT - плавающая запятая (размер зависит от версии Pixilang).
 * FLOAT32 - плавающая запятая (32 бита).
 * FLOAT64 - плавающая запятая (64 бита).
 * DYNAMIC - динамический тип (либо целое, либо плавающая запятая, в зависимости от значения).
 * PIXEL - пиксель; после создания контейнера это значение превращается в INTx, где x - кол-во бит на пиксель.

== Размеры ==

 * INT_SIZE - максимальный размер (в байтах) знакового целого числа, с которым может работать Pixilang.
 * FLOAT_SIZE - максимальный размер (в байтах) числа с плавающей запятой, с которым может работать Pixilang.
 * COLORBITS - количество бит на пиксель.

== Звук ==

Флаги для функции set_audio_callback():
 * AUDIO_FLAG_INTERP2 - линейная интерполяция ( по двум точкам).

== События ==

 * EVT - номер контейнера, в который помещается событие из функции get_event().
Номера ячеек (полей) в контейнере EVT:
 * EVT_TYPE - тип;
 * EVT_FLAGS - флаги;
 * EVT_TIME - время;
 * EVT_X - координата X (0 - центр экрана);
 * EVT_Y - координата Y (0 - центр экрана);
 * EVT_KEY - номер нажатой клавиши;
 * EVT_SCANCODE - сканкод (если имеется);
 * EVT_UNICODE - юникод (если имеется).
Типы событий (для поля EVT_TYPE):
 * EVT_MOUSEBUTTONDOWN;
 * EVT_MOUSEBUTTONUP;
 * EVT_MOUSEMOVE;
 * EVT_TOUCHBEGIN;
 * EVT_TOUCHEND;
 * EVT_TOUCHMOVE;
 * EVT_BUTTONDOWN;
 * EVT_BUTTONUP;
 * EVT_QUIT.
Флаги события (для поля EVT_FLAGS):
 * EVT_FLAG_SHIFT;
 * EVT_FLAG_CTRL;
 * EVT_FLAG_ALT;
 * EVT_FLAG_MODE;
 * EVT_FLAG_MODS (маска модификаторов со всеми флагами типа Shift, Ctrl и т.д.);
 * EVT_FLAG_DOUBLECLICK.
Коды клавиш (для поля EVT_KEY):
 * KEY_MOUSE_LEFT;
 * KEY_MOUSE_MIDDLE;
 * KEY_MOUSE_RIGHT;
 * KEY_MOUSE_SCROLLUP;
 * KEY_MOUSE_SCROLLDOWN;
 * KEY_F1;
 * KEY_F2;
 * KEY_F3;
 * KEY_F4;
 * KEY_F5;
 * KEY_F6;
 * KEY_F7;
 * KEY_F8;
 * KEY_F9;
 * KEY_F10;
 * KEY_F11;
 * KEY_F12;
 * KEY_UP;
 * KEY_DOWN;
 * KEY_LEFT;
 * KEY_RIGHT;
 * KEY_INSERT;
 * KEY_DELETE;
 * KEY_HOME;
 * KEY_END;
 * KEY_PAGEUP;
 * KEY_PAGEDOWN;
 * KEY_CAPS;
 * KEY_SHIFT;
 * KEY_CTRL;
 * KEY_ALT;
 * KEY_UNKNOWN (system virtual key code = code - KEY_UNKNOWN).
Константы для функции set_quit_action():
 * QA_NONE;
 * QA_CLOSE_VM.

== Математические константы ==

 * M_E - e.
 * M_LOG2E - log,,2,,e.
 * M_LOG10E - log,,10,,e.
 * M_LN2 - log,,e,,2.
 * M_LN10 - log,,e,,10.
 * M_PI - PI.
 * M_2_SQRTPI - 2 / sqrt( PI ).
 * M_SQRT2 - sqrt( 2 ).
 * M_SQRT1_2 - 1 / sqrt( 2 ).

== Операции обработки данных ==

Для функций op_cn(), op_cc():
 * OP_ADD - сложение;
 * OP_SADD - сложение с ограничением (защита от переполнения);
 * OP_MUL - умножение;
 * OP_DIV - деление;
 * OP_AND - побитовая операция И;
 * OP_OR - побитовая операция ИЛИ;
 * OP_XOR - побитовая операция исключающего ИЛИ;
 * OP_LSHIFT - битовый сдвиг влево;
 * OP_RSHIFT - битовый сдвиг вправо.

Для функции op_cc():
 * OP_COPY - копирование.

Для функции op_ccn():
 * OP_MUL_DIV - перемножить значения из контейнеров и поделить результат на число. 

Для функции generator():
 * OP_SIN - синус;
 * OP_SIN8 - быстрый, но менее точный синус (вычисляется по таблице 8-битных значений);
 * OP_RAND - псевдо-случайные числа (в диапазоне от -amp до +amp).

== Sampler ==

Номера ячеек (полей) в контейнере с информацией о сэмпле:
 * SMP_DEST - номер контейнера, в который будет производиться запись;
 * SMP_DEST_OFF - смещение в контейнере для записи;
 * SMP_DEST_LEN - длина участка для записи;
 * SMP_SRC - номер контейнера с сэмплом;
 * SMP_SRC_OFF_H - смещение сэмпла (левая часть числа с фиксированной точкой);
 * SMP_SRC_OFF_L - смещение сэмпла (правая часть числа с фиксированной точкой, от 0 до 65535);
 * SMP_LOOP - начало лупа (повторяемого участка сэмпла);
 * SMP_LOOP_LEN - длина лупа (или 0, если луп отключен);
 * SMP_VOL1 - начальная громкость (32768 = 1.0);
 * SMP_VOL2 - конечная громкость (32768 = 1.0);
 * SMP_DELTA - дельта (скорость проигрывания); fixed point {{{(real_value * 65536)}}};
 * SMP_FLAGS - флаги;
 * SMP_INFO_SIZE - размер контейнера с информацией о сэмпле.

Флаги:
 * SMP_FLAG_INTERP2 - линейная интерполяция (по двум точкам);
 * SMP_FLAG_INTERP4 - кубическая сплайновая интерполяция (по четырем точкам);
 * SMP_FLAG_PINGPONG - режим ping-pong для лупа;
 * SMP_FLAG_REVERSE - обратное направление проигрывания.

== Константы для совместимости с POSIX ==

 * FOPEN_MAX.
 * SEEK_CUR.
 * SEEK_END.
 * SEEK_SET.
 * EOF.
 * STDIN.
 * STDOUT.
 * STDERR.

== Разное ==

 * PIXILANG_VERSION - версия Pixilang (major*100000 + minor*100).

= Встроенные глобальные переменные =

 * WINDOW_XSIZE - ширина пользовательского окна (в пикселях).
 * WINDOW_YSIZE - высота пользовательского окна (в пикселях).
 * FPS - текущий фреймрейт.

= Встроенные функции =

== Работа с контейнерами ==

=== new ===

Создать новый контейнер с данными.

Сразу после создания контейнер может быть заполнен неопределенными значениями. Прежде чем читать из этого контейнера, его следует очистить функцией clean, или заполнить полезными данными.

*Параметры ( xsize, ysize, type )*
 * xsize - ширина.
 * ysize - высота.
 * type - тип контейнера (а точнее - тип элементов, из которых состоит контейнер). Возможны следующие типы:
   * INT - знаковое целое (размер зависит от версии Pixilang);
   * INT8 - знаковое целое (8 бит);
   * INT16 - знаковое целое (16 бит);
   * INT32 - знаковое целое (32 бита);
   * INT64 - знаковое целое (64 бита);
   * FLOAT - плавающая запятая (размер зависит от версии Pixilang);
   * FLOAT32 - плавающая запятая (32 бита);
   * FLOAT64 - плавающая запятая (64 бита);
   * DYNAMIC - динамический тип (либо целое, либо плавающая запятая, в зависимости от значения);
   * PIXEL - пиксель; после создания контейнера это значение превращается в INTx, где x - кол-во бит на пиксель.

*Возвращаемое значение*

Номер контейнера или -1, если произошла ошибка при создании.

*Примеры*
{{{
p = new() //Создать контейнер 1x1. Тип = пиксели.
p = new( 4 ) //Создать контейнер 4x1. Тип = пиксели.
p = new( 4, 4 ) //Создать контейнер 4x4. Тип = пиксели.
p = new( 4, 4, FLOAT32 ) //Создать контейнер 4x1. Тип = 32-битные числа с плавающей запятой.
}}}

=== remove ===

Удалить контейнер.

*Параметры ( pixi )*
 * pixi - номер контейнера.

*Примеры*
{{{
p = new() //Создаем новый контейнер
remove( p ) //Удаляем его
}}}

=== resize ===

Изменить параметры контейнера.

*Параметры ( pixi, xsize, ysize, type )*
 * pixi - номер контейнера.
 * xsize - ширина.
 * ysize - высота.
 * type - тип контейнера (а точнее - тип элементов, из которых состоит контейнер). Возможны следующие типы:
   * INT8 - знаковое целое (8 бит);
   * INT16 - знаковое целое (16 бит);
   * INT32 - знаковое целое (32 бита);
   * INT64 - знаковое целое (64 бита);
   * FLOAT32 - плавающая запятая (32 бита);
   * FLOAT64 - плавающая запятая (64 бита);
   * DYNAMIC - динамический тип (либо целое, либо плавающая запятая, в зависимости от значения);
   * PIXEL - пиксель; после создания контейнера это значение превращается в INTx, где x - кол-во бит на пиксель.

-1 в любом из параметров будет означать, что данный параметр контейнера остается прежним.

*Возвращаемое значение*

0 - успешно; 1 - ошибка.

*Примеры*
{{{
p = new() //Создаем новый контейнер 1x1
resize( p, 32 ) //Изменяем его размер на 32x1
remove( p ) //Удаляем контейнер
}}}

=== convert_type ===

Преобразовать значения контейнера к другому типу.

*Параметры ( pixi, new_type )*

=== clean ===

Очистить контейнер (заполнить нулями или указанным значением).

*Параметры ( pixi, v )*
 * pixi - номер контейнера;
 * v -  число, которым надо заполнить контейнер (если не указано, то заполняем нулями).

*Примеры*
{{{
p = new() //Создаем новый контейнер
clean( p ) //Очищаем его
remove( p ) //И удаляем
}}}

=== clone ===

Создать точную копию контейнера.

*Параметры ( pixi )*
 * pixi - номер контейнера.

*Возвращаемое значение*

Номер нового контейнера или -1, если произошла ошибка при создании.

=== copy ===

Скопировать данные из контейнера src в контейнер dest.

*Parameters ( dest, src, dest_offset, src_offset, size, step )*

*Examples*
{{{
//Скопировать все элементы из контейнера img1 в img2:
copy( img2, img1 )
//Скопировать элементы 8...200 из контейнера img1 в img2:
copy( img2, img1, 8, 8, 200 )
//Скопировать элементы 8...200 из контейнера img1 в img2 с шагом 2:
copy( img2, img1, 8, 8, 200, 2 )
}}}

=== get_size ===

Получить размер контейнера (кол-во элементов).

*Параметры ( pixi )*
 * pixi - номер контейнера.

*Возвращаемое значение*

Размер контейнера (кол-во элементов).

*Примеры*
{{{
p = new( 8, 8 ) //Создаем новый контейнер 8x8
size = get_size( p ) //Записываем его размер в переменную size
remove( p ) //Удаляем контейнер
}}}

=== get_xsize ===

Получить ширину контейнера.

*Параметры ( pixi )*
 * pixi - номер контейнера.

*Возвращаемое значение*

Ширина контейнера.

*Примеры*
{{{
p = new( 8, 8 ) //Создаем новый контейнер 8x8
xsize = get_xsize( p ) //Записываем его ширину в переменную xsize
remove( p ) //Удаляем контейнер
}}}

=== get_ysize ===

Получить высоту контейнера.

*Параметры ( pixi )*
 * pixi - номер контейнера.

*Возвращаемое значение*

Высота контейнера.

*Примеры*
{{{
p = new( 8, 8 ) //Создаем новый контейнер 8x8
ysize = get_xsize( p ) //Записываем его высоту в переменную ysize
remove( p ) //Удаляем контейнер
}}}

=== get_esize ===

Получить размер элемента контейнера (в байтах).

*Параметры ( pixi )*
 * pixi - номер контейнера.

*Возвращаемое значение*

Размер элемента контейнера (в байтах).

*Примеры*
{{{
p = new( 8, 8, INT16 ) //Создаем новый контейнер 8x8; тип элемента = INT16
esize = get_esize( p ) //Записываем размер его элемента в переменную esize
//Теперь в переменной esize находится число 2 (т.к. 16 бит - это два байта).
remove( p ) //Удаляем контейнер
}}}

=== get_type ===

Получить тип элемента контейнера.

*Параметры ( pixi )*
 * pixi - номер контейнера.

*Возвращаемое значение*

Тип элемента контейнера.

*Примеры*
{{{
p = new( 8, 8, INT32 ) //Создаем новый контейнер 8x8; тип элемента = INT32
type = get_type( p ) //Записываем тип его элемента в переменную type
//Теперь в переменной type находится константа INT32.
remove( p ) //Удаляем контейнер
}}}

== Текстовые строки ==

=== num_to_str ===

Альтернативные имена: num2str.

Конвертировать число из переменной в текстовую строку (в контейнер).

*Параметры ( str, num )*
 * str - контейнер для строки;
 * num - число.

*Примеры*
{{{
v = 45.64
s = ""
num_to_str( s, v )
fputs( s ) fputs( "\n" )
}}}

=== str_to_num ===

Альтернативные имена: str2num.

Конвертировать текста (из контейнера) в число.

*Параметры ( str )*
 * str - контейнер со строкой.

*Возвращаемое значение*

Числовое значение.

*Примеры*
{{{
a = str_to_num( "-55.44" )
b = a + 4
}}}

== Поддержка различных форматов файлов ==

=== load ===

== Графика ==

=== frame ===

Вывести содержимое рабочего экрана на дисплей и подождать указанное количество миллисекунд.

*Параметры ( delay, x, y, xsize, ysize )*
 * delay - длинна паузы (в миллисекундах), которую нужно выждать после вывода на экран. По разным причинам пауза может оказаться длиннее, например, если система притормозила, или в системе неточный таймер;
 * x, y, xsize, ysize - необязательные параметры, указывающие, какой регион текущего экрана надо вывести.

=== set_screen ===

Сделать указанный контейнер текущим рабочим экраном.

*Параметры ( pixi )*
 * pixi - номер контейнера.

=== get_screen ===

Получить номер контейнера, который в данный момент является рабочим экраном.

*Возвращаемое значение*

Номер контейнера, который является рабочим экраном.

=== set_zbuf ===

=== get_zbuf ===

=== get_color ===

Получить значение цвета с заданными характеристиками r,g,b (красный,зеленый,синий). 

*Параметры ( red, green, blue )*
 * red - интенсивность красного (от 0 до 255);
 * green - интенсивность зеленого (от 0 до 255);
 * blue - интенсивность синего (от 0 до 255);

*Возвращаемое значение*

Значение цвета. Формат этого значения может меняться в зависимости от версии Pixilang. Например, если Pixilang скомпилирован для устройств с 8-битным дисплеем, то значение цвета будет в диапазоне от 0 до 255.

=== get_red ===

Получить интенсивность красной составляющей в указанном цвете.

*Параметры ( color )*
 * color - цвет.

*Возвращаемое значение*

Интенсивность красной составляющей. От 0 до 255.

=== get_green ===

Получить интенсивность зеленой составляющей в указанном цвете.

*Параметры ( color )*
 * color - цвет.

*Возвращаемое значение*

Интенсивность зеленой составляющей. От 0 до 255.

=== get_blue ===

Получить интенсивность синей составляющей в указанном цвете.

*Параметры ( color )*
 * color - цвет.

*Возвращаемое значение*

Интенсивность синей составляющей. От 0 до 255.

=== get_blend ===

Получить промежуточное значение цвета между двумя известными.

*Параметры ( c1, c2, v )*
 * c1 - первый цвет;
 * с2 - второй цвет;
 * v - положение между c1 и c2; 0 - ближе всего к c1; 255 - ближе всего к c2.

*Возвращаемое значение*

Промежуточное значение цвета.

=== transp ===

Установить прозрачность для всех последующих функций.

*Параметры ( t )*
 * t - значение прозрачности от 0 (невидимый) до 255 (непрозрачный).

=== get_transp ===

Получить текущее значение прозрачности.

=== clear ===

Очистить текущий рабочий экран заданным цветом (или черным, если цвет не задан).

*Параметры ( color )*
 * color - цвет.

=== dot ===

Нарисовать точку.

*Параметры ( x, y, color )*
 * x - координата X;
 * y - координата Y;
 * color - цвет.

=== dot3d ===

=== get_dot ===

Получить цвет в указанной точке.

*Параметры ( x, y )*
 * x - координата X;
 * y - координата Y.

*Возвращаемое значение*

Значение цвета в указанной точке.

=== get_dot3d ===

=== line ===

=== line3d ===

=== box ===

=== fbox ===

=== pixi ===

Вывести на экран контейнер с картинкой.

*Параметры ( pixi, x, y, color, xscale, yscale )*
 * pixi - номер контейнера с картинкой;
 * x;
 * y;
 * color - цвет фильтра; опциональный; значение по умолчанию - WHITE (пропускаются все цвета);
 * xscale - коэффициент масштабирования по оси X; опциональный; значение по умолчанию - 1;
 * yscale - коэффициент масштабирования по оси Y; опциональный; значение по умолчанию - 1.

*Примеры*
{{{
pixi( image )
pixi( image, 10, 20 )
pixi( image, 30, 40, GREEN )
pixi( image, 90, 20, GREEN, 0.5, 0.5 )
}}}

=== set_key_color ===

Установить/сбросить цвет прозрачности у контейнера.

*Параметры ( pixi, color )*
 * pixi - номер контейнера;
 * color - цвет, который будет прозрачным; если цвет не указать, прозрачность для контейнера pixi выключится.

=== get_key_color ===

=== set_alpha ===

Привязать к контейнеру другой контейнер с альфа-каналом. Альфа-канал должен иметь тип INT8.

*Параметры ( pixi, alpha )*
 * pixi - номер контейнера;
 * alpha - номер контейнера с альфа-каналом; если этот параметр не указать, то альфа-канал выключится для контейнера pixi.

=== get_alpha ===

=== print ===

Вывести текст на экран.

*Параметры ( text, x, y, color, align )* 
 * text - номер контейнера с текстом;
 * x, y - координаты точки, относительно которой происходит выравнивание;
 * color - цвет;
 * align - выравнивание.

*Примеры*
{{{
print( "Hello Pixi!", 0, 0 ) //цвет - белый; выравнивание - по центру;
print( "line1\nline2", 50, 50, RED ) //выравнивание - по центру;
print( "line1\nline2", -50, 50, RED, TOP | LEFT ) //выравнивание - по верхнему левому краю;
}}}

=== set_font ===

*Параметры ( first_char, pixi, xchars, ychars )*

== Трансформация ==

=== t_reset ===

=== t_rotate ===

=== t_translate ===

=== t_scale ===

=== t_get_matrix ===

=== t_set_matrix ===

=== t_mul_matrix ===

=== t_point ===

== Звук ==

=== set_audio_callback ===

Задать функцию, которая будет генерировать звуковой поток.

*Параметры ( callback, userdata, freq, format, channels, flags )*

*Примеры*
{{{
fn audio_callback( $stream, $userdata, $channels, $frames, $time )
{
  generator( OP_SIN, $channels[ 0 ], 0, 32767 / 2, 0.1, 0 ) //Левый канал
  generator( OP_SIN, $channels[ 1 ], 0, 32767 / 2, 0.1, 0 ) //Правый канал
  ret(1)
}
set_audio_callback( audio_callback, 0, 22050, INT16, 2, AUDIO_FLAG_INTERP2 )
}}}

== Время ==

=== start_timer ===

Запустить таймер.

*Параметры ( timer_num )*
 * timer_num - номер таймера.

=== get_timer ===

Получить значение таймера в миллисекундах.

*Параметры ( timer_num )*
 * timer_num - номер таймера.

*Возвращаемое значение*

32-битное значение таймера в миллисекундах.

=== get_year ===

=== get_month ===

=== get_day ===

=== get_hours ===

=== get_minutes ===

=== get_seconds ===

=== get_ticks ===

Получить значение системного 32-битного таймера высокого разрешения. Единица измерения - 1 тик.

=== get_tps ===

Получить количество системных тиков в секунду.

=== sleep ===

Заснуть на указанный промежуток времени.

*Параметры ( delay )*
 * delay - длина задержки в миллисекундах.

== События ==

=== get_event ===

Получить очередное событие от системы. 

*Возвращаемое значение*

0 - нет новых событий. 1 - очередное событие получено и оно находится в контейнере EVT.

=== set_quit_action ===

Установить поведение программы при получении события EVT_QUIT.

*Параметры ( action )*
 * action - номер действия, которое нужно выполнять при получении события EVT_QUIT.

Возможные значения параметра action:
 * QA_NONE - ничего не делать;
 * QA_CLOSE_VM (по умолчанию) - закрыть текущую виртуальную машину, но не выходить из Pixilang.

== Многопоточность ==

=== thread_create ===

Создать новый поток выполнения, в котором сразу после создания будет запущена функция thread_function( $user_data )

*Параметры ( thread_function, user_data )*

*Возвращаемое значение*

Номер потока или -1 в случае ошибки.

=== thread_destroy ===

Закрыть поток выполнения.

*Параметры ( thread_num, timeout_ms )*

*Возвращаемое значение*

В случае успешного закрытия потока возвращается 0.

=== mutex_create ===

=== mutex_destroy ===

=== mutex_lock ===

=== mutex_trylock ===

=== mutex_unlock ===

== Математика ==

=== acos ===
=== acosh ===
=== asin ===
=== asinh ===
=== atan ===
=== atanh ===
=== ceil ===
=== cos ===
=== cosh ===
=== exp ===
=== exp2 ===
=== expm1 ===
=== abs ===
=== floor ===
=== mod ===
=== log ===
=== log2 ===
=== log10 ===
=== pow ===
=== sin ===
=== sinh ===
=== sqrt ===
=== tan ===
=== tanh ===
=== rand ===
=== rand_seed ===

== Обработка данных ==

Примечание: функции обработки данных не работают с контейнерами динамического типа.

=== op_cn ===

Выполнить операцию обработки данных. 
Операнды: 1) номер контейнера (c); 2) числовое значение (n).

*Параметры ( opcode, pixi, num, x, y, xsize, ysize )*
 * opcode - код операции;
 * pixi - номер контейнера (c);
 * num - числовое значение (n);
 * x,y,xsize,ysize - регион, в котором будет выполняться операция.

*Примеры*
{{{
//Прибавить число 32 к каждому элементу контейнера img:
op_cn( OP_ADD, img, 32 )

//Прибавить число 32 к элементам 128...256:
op_cn( OP_ADD, img, 32, 128, 128 ) 

//Прибавить число 32 к элементам в регионе (8,8,32,32):
op_cn( OP_ADD, img, 32, 8, 8, 32, 32 )
}}}

=== op_cc ===

Выполнить операцию обработки данных. 
Операнды: 1) номер контейнера (c); 2) номер контейнера (c).

Как работает: {{{для каждого элемента из контейнера pixi1: pixi1[ i ] = pixi1[ i ] OP pixi2[ i ]}}}

*Параметры ( opcode, pixi1, pixi2 ) - для всей области контейнера pixi1*

*Параметры ( opcode, pixi1, pixi2, dest_x, src_x, xsize ) - область задана в 1D координатах*

*Параметры ( opcode, pixi1, pixi2, dest_x, dest_y, src_x, src_y, xsize, ysize ) - область задана в 2D координатах*

=== op_ccn ===

Выполнить операцию обработки данных. 
Операнды: 1) номер контейнера (c); 2) номер контейнера (c); 3) числовое значение (n).

Как работает: {{{для каждого элемента из контейнера pixi1: pixi1[ i ] = pixi1[ i ] OP pixi2[ i ] / num}}}

*Параметры ( opcode, pixi1, pixi2, num ) - для всей области контейнера pixi1*

*Параметры ( opcode, pixi1, pixi2, num, dest_x, src_x, xsize ) - область задана в 1D координатах*

*Параметры ( opcode, pixi1, pixi2, num, dest_x, dest_y, src_x, src_y, xsize, ysize ) - область задана в 2D координатах*

=== generator ===

Генератор сигнала.

*Параметры ( opcode, pixi, phase, amplitude, delta_x, delta_y, x, y, xsize, ysize )*
 * opcode - код операции;
 * pixi - номер контейнера;
 * phase - начальная фаза;
 * amplitude - амплитуда;
 * delta_x - скорость изменения фазы по горизонтали;
 * delta_y - скорость изменения фазы по вертикали;
 * x,y,xsize,ysize - регион, в котором будет выполняться операция.

*Примеры*
{{{
//Сгенерировать синусоиду в контейнер img:
generator( OP_SIN, img, 0, 1, 0.1, 0.1 )

//Сгенерировать синусоиду по более быстрому, но менее точному алгоритму:
generator( OP_SIN8, img, 0, 1, 0.1, 0.1 )

//Сгенерировать синусоиду в элементы 8...128 контейнера img:
generator( OP_SIN, img, 0, 1, 0.1, 0.1, 8, 128 )

//Сгенерировать синусоиду в регион (8,8,32,32) контейнера img:
generator( OP_SIN, img, 0, 1, 0.1, 0.1, 8, 8, 32, 32 )
}}}

=== sampler ===

*Параметры ( sample_info )*

*Примеры*
{{{
sample_data = new( 256, 1, INT16 ) //создаем 16-битный сэмпл
sample_info = new( SMP_INFO_SIZE, 1, INT32 ) //создаем контейнер для сэмплера
clean( sample_info )
sample_info[ SMP_DEST ] = buffer //Контейнер, в который будем записывать
sample_info[ SMP_DEST_OFF ] = 0 //Смещение в контейнере
sample_info[ SMP_DEST_LEN ] = 256 //Размер области, которую будем заполнять
sample_info[ SMP_SRC ] = sample_data
sample_info[ SMP_SRC_OFF_H ] = 0 //Смещение сэмпла (левая часть числа с фиксированной точкой)
sample_info[ SMP_SRC_OFF_L ] = 0 //Смещение сэмпла (правая часть числа с фиксированной точкой, от 0 до 65535)
sample_info[ SMP_LOOP ] = 0 //Начало лупа (повторяемого участка сэмпла)
sample_info[ SMP_LOOP_LEN ] = 128 //Длина лупа (или 0, если луп отключен)
sample_info[ SMP_VOL1 ] = 0 //Начальная громкость
sample_info[ SMP_VOL2 ] = 32768 //Конечная громкость (32768 = 1.0)
sample_info[ SMP_DELTA ] = ( 1 << 16 ) //Дельта (скорость проигрывания); fixed point (real_value * 65536)
sample_info[ SMP_FLAGS ] = SMP_FLAG_INTERP4 | SMP_FLAG_PINGPONG //Кубическая сплайновая интерполяция и луп в режиме ping-pong
sampler( sample_info ) //Записываем сэмпл с выбранными параметрами в контейнер buffer
}}}

=== fft ===

Выполнить быстрое преобразование Фурье.

*Параметры ( inverse, im, re, size )*

=== replace_values ===

Подстановка значений контейнера. Типы контейнеров dest и values должны быть одинаковыми. Для каждого элемента контейнера dest будет выполняться следующее действие: {{{dest[ i ] = values[ (unsigned)src[ i ] ]}}}

*Параметры ( dest, src, values )*
 * dest - куда;
 * src - откуда;
 * values - подставляемые значения.

*Примеры*
{{{
//Преобразовать 8-битную картинку в формат пикселей текущего экрана:
//src - это, например, контейнер основного экрана;
//img8 - контейнер с 8-битной картинкой (256 цветов);
//palette - контейнер с палитрой из 256 цветов;
replace_values( scr, img8, palette )
}}}

== Диалоги ==

=== file_dialog ===

Открыть диалоговое окно выбора файла.

*Параметры ( dialog_name, mask, id )*
 * dialog_name - название окна;
 * mask - типы файлов (например, "gif/jpg");
 * id - имя файла, в который будет сохраняться состояние текущего диалога (например, "myprogram_jpeg_files").

*Возвращаемое значение*

Номер контейнера с именем выбранного файла, или -1, если файл не выбран. Контейнер удаляется вручную.

== Системные функции (совместимость с POSIX) ==

=== fopen ===

*Параметры ( filename, mode )*

*Примеры*
{{{
f = fopen( "/tmp/data.txt", "rb" ) //Открываем файл data.txt для чтения
fclose( f ) //...и закрываем его.
}}}

=== fclose ===

*Параметры ( stream )*

*Примеры*
{{{
f = fopen( "/tmp/data.txt", "rb" ) //Открываем файл data.txt для чтения.
c = fgetc( f ) //Получаем байт из этого файла.
fclose( f ) //Закрываем файл.
}}}

=== fputc ===

*Параметры ( c, stream )*

*Примеры*
{{{
f = fopen( "/tmp/data.txt", "wb" ) //Открываем файл data.txt для записи.
fputc( 0x12, f ) //Записываем байт 0x12 в этот файл.
fclose( f ) //Закрываем файл.
}}}

=== fputs ===

*Параметры ( s, stream )*

*Примеры*
{{{
f = fopen( "/tmp/data.txt", "wb" ) //Открываем файл data.txt для записи.
str = "Hello!"
fputc( str, f ) //Записываем строку "Hello!" в этот файл.
fclose( f ) //Закрываем файл.
}}}

=== fwrite ===

*Параметры ( data, size, stream )*

*Примеры*
{{{
f = fopen( "/tmp/data.txt", "wb" ) //Открываем файл data.txt для записи.
str = "Hello!"
fwrite( str, 2, f ) //Записываем первые два байта из контейнера str в этот файл.
fclose( f ) //Закрываем файл.
}}}

=== fgetc ===

*Параметры ( stream )*

=== fgets ===

*Параметры ( s, n, stream )*

*Примеры*
{{{
string = new( 256, 1, INT8 )
f = fopen( "/tmp/data.txt", "rb" ) //Открываем файл data.txt для чтения.
fgets( string, 256, f ) //Получаем строку текста из этого файла.
//Полученная строка помещается в указанный выше контейнер string.
//Если в контейнере недостаточно места, то строка обрезается.
fclose( f ) //Закрываем файл.
}}}

=== fread ===

*Параметры ( data, size, stream )*

=== feof ===

*Параметры ( stream )*

=== fflush ===

*Параметры ( stream )*

=== fseek ===

*Параметры ( stream, offset, origin )*

=== ftell ===

*Параметры ( stream )*

*Примеры*
{{{
//Один из способов получения размера файла:
f = fopen( "/tmp/data.txt", "rb" )
fseek( f, 0, SEEK_END )
size_of_file = ftell( f )
fclose( f )
}}}

=== remove_file ===

*Параметры ( filename )*

=== rename_file ===

*Параметры ( old_filename, new_filename )*

=== strcat ===

Добавляет строку source к строке destination. Обе строки должны заканчиваться символом с кодом 0, если кол-во остальных символов в строке меньше размера контейнера, в котором строка находится. После выполнения этой функции размер контейнера destination может увеличиться, если в нем не хватит места для строки source.

*Параметры ( destination, source )*

=== strcmp ===

Сравнивает две строки str1 и str2. Обе строки должны заканчиваться символом с кодом 0, если кол-во остальных символов в строке меньше размера контейнера, в котором строка находится.

*Параметры ( str1, str2 )*

*Возвращаемое значение*

 * Меньше нуля - str1 меньше str2. 
 * Больше нуля - str1 больше str2. 
 * 0 - str1 равна str2.

=== strlen ===

Возвращает длину строки. Завершающий символ с кодом 0 не учитывается. Строки должна заканчиваться символом с кодом 0, если кол-во остальных символов в строке меньше размера контейнера, в котором строка находится.

*Параметры ( str )*

*Возвращаемое значение*

Длина строки.

=== strstr ===

Ищет первое вхождение подстроки str2 в строке str1. Обе строки должны заканчиваться символом с кодом 0, если кол-во остальных символов в строке меньше размера контейнера, в котором строка находится.

*Параметры ( str1, str2 )*

*Возвращаемое значение*

Функция возвращают смещение подстроки str2 в строке str1, или -1, если подстрока не найдена. 

=== sprintf ===

Форматирует и запоминает наборы символов и значений в str. Каждый аргумент (если он есть), преобразуется и выводится согласно соответствующей спецификации формата в format.

*Параметры ( str, format, ... )*

*Возвращаемое значение*

Возвращает количество символов, записанных в str. В случае ошибки возвращается отрицательное значение.

=== system ===

Выполнить системную команду.

*Параметры ( command )*

*Примеры*
{{{
//Удаляем файл в Unix-совместимой ОС:
system( "rm /tmp/data.txt" )
}}}

=== argc ===

=== argv ===

*Параметры ( n )*

*Примеры*
{{{
if argc >= 4 
{
  a = argv( 3 )
  remove( a )
}
}}}

=== exit ===

Выйти из Pixilang.

*Примеры*
{{{
exit( 4 ) //Выйти с кодом 4
}}}